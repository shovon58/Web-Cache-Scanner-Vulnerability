package main

import (
	"bufio"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/Hackmanit/Web-Cache-Vulnerability-Scanner/v2/pkg"
	"golang.org/x/net/http2"
)

/*
Build module

go get ./...

sudo /usr/local/go/bin/go clean -cache -modcache -i -r

go mod tidy

env GOOS=windows GOARCH=amd64 go build
go build
set GOOS=
set GOARCH=
go build
*/

const version = "1.0.0"

var currentDate string

var report pkg.Report

func main() {
	//pkg.ReadConfigFile()
	pkg.ParseFlags(version)
	/*****************************/

	/**** SET EXPORT STRUCT ****/
	report.Name = "Web_Cache_Vulnerability_Scanner"
	report.Version = version

	report.Config = &pkg.Config
	/***************************/

	// Check pkg.Config if Log shall be printed or no logs shall be made
	/* Setting Logoutput to Log file and stdout */
	f, err := os.OpenFile("web-cache-poisoning-scanner.log", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		msg := "Log: " + err.Error() + "\n"
		pkg.PrintFatal(msg)
	}
	defer f.Close()
	//wrt := io.MultiWriter(f, os.Stdout)
	//log.SetOutput(wrt)
	log.SetOutput(f)
	/******************************************/
	if pkg.Config.Verbosity < 0 || pkg.Config.Verbosity > 2 {
		msg := fmt.Sprintf("%d is not a valid verbosity between 0 and 2!\n", pkg.Config.Verbosity)
		pkg.PrintFatal(msg)
	}

	currentDate = time.Now().Format("2006-01-02_15:04:05")

	msg := fmt.Sprintf("Application started at %s\n", currentDate)
	pkg.PrintVerbose(msg, pkg.NoColor, 1)

	start := time.Now()
	// Making the random generator really random
	rand.Seed(time.Now().UnixNano())

	noTestPreference := true
	if pkg.Config.DoTest != "" && pkg.Config.DontTest != "" {
		msg = "You can't set both doTest and dontTest\n"
		pkg.PrintFatal(msg)
	} else if pkg.Config.DoTest != "" {
		noTestPreference = false
	} else if pkg.Config.DontTest != "" {
		noTestPreference = false
	}

	if pkg.Config.ReportPath != "" {
		pkg.Config.GenerateReport = true
	}
	if pkg.Config.CompletedPath != "" {
		pkg.Config.GenerateCompleted = true
	}

	var completedFile *os.File
	if pkg.Config.GenerateCompleted {
		completedFile = createCompletedURLs()
	}
	/***************************/

	/* Setting up proxy (e.g. burp), if wanted */
	if pkg.Config.ProxyCertPath != "" {
		setProxy(pkg.Config.ProxyURL, pkg.Config.ProxyCertPath)
	}
	/*******************************************/

	// Reading header wordlist, only if it is needed
	var headerList []string
	if noTestPreference || strings.Contains(pkg.Config.DoTest, "header") || (pkg.Config.DontTest != "" && !strings.Contains(pkg.Config.DontTest, "header")) {
		headerList = pkg.ReadLocalFile(pkg.Config.HeaderWordlist)
	}

	// Reading parameter wordlist, only if it is needed
	var parameterList []string
	if noTestPreference || strings.Contains(pkg.Config.DoTest, "parameter") || (pkg.Config.DontTest != "" && !strings.Contains(pkg.Config.DontTest, "parameter")) {
		parameterList = pkg.ReadLocalFile(pkg.Config.QueryWordlist)
	}
	/*******************************************************/

	excluded := make(map[string]bool)

	for _, u := range pkg.Config.RecExclude {
		u = strings.TrimSuffix(u, "\r")
		u = strings.TrimSpace(u)

		// check if empty or is a comment
		if u == "" || strings.HasPrefix(u, "//") {
			continue
		}
		if !strings.HasPrefix(u, "http://") && !strings.HasPrefix(u, "https://") {
			msg = fmt.Sprintf("URL %s doesn't begin with http:// or https:// and gets skipped\n", u)
			pkg.Print(msg, pkg.Yellow)
			continue
		}

		excluded[u] = true
	}

	//pkg.Config.Website.Added = make(map[string]bool)
	added := make(map[string]bool)

	var testUrls []string
	for _, u := range pkg.Config.Urls {
		u = strings.TrimSuffix(u, "\r")
		u = strings.TrimSpace(u)

		// check if empty or is a comment
		if u == "" || strings.HasPrefix(u, "//") {
			continue
		}
		if !strings.HasPrefix(u, "http://") && !strings.HasPrefix(u, "https://") {
			msg = fmt.Sprintf("URL %s doesn't begin with http:// or https:// and gets skipped\n", u)
			pkg.Print(msg, pkg.Yellow)
			continue
		}

		added[u] = true
		testUrls = append(testUrls, u)
	}

	for rec := 0; rec <= pkg.Config.Recursivity; rec++ {
		var foundUrls []string

		for i, u := range testUrls {

			msg := fmt.Sprintf("Testing website(%d/%d): %s\n", i+1, len(testUrls), u)
			pkg.Print(msg, pkg.NoColor)
			fmt.Printf("-----------------------------------------------------------------------\n")

			/* Setting up client: cookies and noredirect */
			msg = "Setting up client\n"
			pkg.PrintVerbose(msg, pkg.NoColor, 2)

			// Setting cookies, speficied by setcookies
			pkg.Config.Website.Cookies = []*http.Cookie{}
			for _, c := range pkg.Config.Cookies {
				c = strings.TrimSuffix(c, "\r")
				c = strings.TrimSpace(c)
				if c == "" {
					continue
				} else if !strings.Contains(c, "=") {
					msg = "Specified cookie %s doesn't contain a = and will be skipped\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 2)
					continue
				} else {
					cSlice := strings.SplitAfterN(c, "=", 2)
					cSlice[0] = strings.TrimSuffix(cSlice[0], "=")

					cookie := http.Cookie{
						Name:  cSlice[0],
						Value: cSlice[1],
					}
					pkg.Config.Website.Cookies = append(pkg.Config.Website.Cookies, &cookie)
				}
			}

			timeOutDuration := time.Duration(time.Duration(pkg.Config.TimeOut) * time.Second)
			clientNoRedir := http.Client{
				CheckRedirect: func(redirRequest *http.Request, via []*http.Request) error {
					msg := fmt.Sprintf("Redirect Request denied: %s\n", redirRequest.Header)
					pkg.PrintVerbose(msg, pkg.Yellow, 2)
					return http.ErrUseLastResponse
				},
				Timeout: timeOutDuration,
			}

			// retrieve cookies
			pkg.Config.Website = pkg.GetWebsite(u, clientNoRedir, true)

			if !pkg.Config.DeclineCookies {
				// retrieve response with all cookies set
				pkg.Config.Website = pkg.GetWebsite(u, clientNoRedir, false)
			}

			// check if there's a cache and the cachebuster works
			pkg.Config.Website.Cache = pkg.CheckCache(clientNoRedir)

			/*******************************************/

			if pkg.Config.Website.Cache.Indicator != "" || pkg.Config.Force {
				fmt.Println()

				/* Testing for cookie poisoning */
				if noTestPreference || strings.Contains(pkg.Config.DoTest, "cookie") || (pkg.Config.DontTest != "" && !strings.Contains(pkg.Config.DontTest, "cookie")) {
					msg = "Testing for cookie poisoning\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)

					report.Results = append(report.Results, pkg.ScanCookies(clientNoRedir))

					if len(pkg.Config.Website.Cookies) == 0 {
						errMsg := "There were no cookies to test!"
						pkg.Print(errMsg+"\n", pkg.Yellow)

						report.Results[len(report.Results)-1].ErrorMessage = errMsg
						report.Results[len(report.Results)-1].HasError = true
					}
				} else {
					msg = "Skipping to test for cookie poisoning\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)

				}
				/*****************************/

				/* Testing for multiple forwarding headers for poisoning */
				if noTestPreference || strings.Contains(pkg.Config.DoTest, "forward") || (pkg.Config.DontTest != "" && !strings.Contains(pkg.Config.DontTest, "forward")) {
					msg = "Testing multiple forwarding headers for poisoning\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)

					report.Results = append(report.Results, pkg.ScanForwardingHeaders(clientNoRedir))
				} else {
					msg = "Skipping to test multiple forwarding headers for poisoning\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
				}
				/*************************************************************/

				/* Testing for multiple Cache Poisoned Denial Of Service Techniques */
				if noTestPreference || strings.Contains(pkg.Config.DoTest, "dos") || (pkg.Config.DontTest != "" && !strings.Contains(pkg.Config.DontTest, "dos")) {
					msg = "Testing for multiple Cache Poisoned Denial Of Service Techniques\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)

					report.Results = append(report.Results, pkg.DOS(clientNoRedir))
				} else {
					msg = "Skipping to test for multiple Cache Poisoned Denial Of Service Techniques\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
				}
				/***********************************************************/

				/* Testing for header poisoning */
				if noTestPreference || strings.Contains(pkg.Config.DoTest, "header") || (pkg.Config.DontTest != "" && !strings.Contains(pkg.Config.DontTest, "header")) {
					msg = "Testing for header poisoning\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)

					report.Results = append(report.Results, pkg.ScanHeaders(clientNoRedir, headerList))
				} else {
					msg = "Skipping to test for header poisoning\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
				}
				/********************************/

				/* Testing for query parameter poisoning */
				if noTestPreference || strings.Contains(pkg.Config.DoTest, "parameter") || (pkg.Config.DontTest != "" && !strings.Contains(pkg.Config.DontTest, "parameter")) {
					msg = "Testing for query parameter poisoning\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
					report.Results = append(report.Results, pkg.ScanParameters(clientNoRedir, parameterList))
				} else {
					msg = "Skipping to test for query parameter poisoning\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
				}
				/*****************************************/

				/* Testing for Fat GET */
				if pkg.Config.DoPost {
					msg = "Can't check for Fat GET, because POST was specified\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
				} else if noTestPreference || strings.Contains(pkg.Config.DoTest, "fat") || (pkg.Config.DontTest != "" && !strings.Contains(pkg.Config.DontTest, "fat")) {
					msg = "Testing for Fat GET\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)

					report.Results = append(report.Results, pkg.ScanFatGET(clientNoRedir))
				} else {
					msg = "Skipping to test for Fat GET\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
				}
				/**********************/

				/* Testing for Parameter Cloaking */
				if pkg.Config.DoPost {
					msg = "Can't check for Parameter Cloaking, because POST was specified\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
				} else if noTestPreference || strings.Contains(pkg.Config.DoTest, "cloaking") || (pkg.Config.DontTest != "" && !strings.Contains(pkg.Config.DontTest, "cloaking")) {
					msg = "Testing for Parameter Cloaking\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)

					report.Results = append(report.Results, pkg.ScanParameterCloaking(clientNoRedir))
				} else {
					msg = "Skipping to test for Parameter Cloaking\n"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
				}
				/**********************************/
			}

			/* Check for linked files */
			if pkg.Config.Recursivity > rec {
				msg = fmt.Sprintf("\nChecking recursively for urls (%d/%d)\n", rec+1, pkg.Config.Recursivity)
				pkg.Print(msg, pkg.NoColor)

				tempUrls := pkg.CrawlUrls(added, excluded)

				if len(tempUrls) > 0 {
					msg = fmt.Sprintf("Found %d urls", len(tempUrls))
					pkg.Print(msg, pkg.NoColor)

					msg = ". Adding the following urls to the Queue:"
					pkg.PrintVerbose(msg, pkg.NoColor, 1)
					pkg.PrintVerbose("\n", pkg.NoColor, 0)
					for _, u := range tempUrls {
						pkg.PrintVerbose(u+"\n", pkg.NoColor, 1)
					}

					foundUrls = append(foundUrls, tempUrls...)
				} else {
					msg = "No urls were found to add to the queue"
					pkg.Print(msg, pkg.NoColor)
				}
			}
			/**************************/

			if pkg.Config.GenerateCompleted {
				_, err = completedFile.WriteString(u + "\n")
				if err != nil {
					pkg.Print("Writing to completed URLs file: "+err.Error(), pkg.Red)
				}
			}

			fmt.Printf("\n-----------------------------------------------------------------------\n")
		}

		if pkg.Config.Recursivity > 0 && len(foundUrls) == 0 {
			msg = "No more urls found to check!\n"
			pkg.Print(msg, pkg.NoColor)
			break
		}
		testUrls = foundUrls
	}

	/* Scan finished */
	msg = "Successfully finished the scan\n"
	pkg.PrintVerbose(msg, pkg.NoColor, 1)

	duration := time.Since(start)
	msg = fmt.Sprintf("Duration: %s\n\n", duration)
	pkg.PrintVerbose(msg, pkg.NoColor, 1)
	/****************/

	generateReport(duration)
}

func generateReport(duration time.Duration) {
	skipReportRetry := pkg.Config.DontRetryReport
	for pkg.Config.GenerateReport && !skipReportRetry {
		report.Vulnerable = len(report.Results) > 0
		report.Date = currentDate
		report.Duration = duration.String()
		err := pkg.ExportReport(report, pkg.Config.EscapeJSON)

		if err != nil {
			reader := bufio.NewReader(os.Stdin)
			pkg.Print("Enter f for the report to be generated again. Enter any other char to exit the scan.\n-> ", pkg.Blue)
			input, err := reader.ReadString('\n')
			if err != nil {
				pkg.Print(err.Error(), pkg.Yellow)
			} else {
				if !strings.Contains(input, "f") {
					skipReportRetry = true
				}
			}
		} else {
			skipReportRetry = true
		}
	}
}

func createCompletedURLs() *os.File {
	completedPath := report.Config.CompletedPath
	if completedPath == "" || strings.HasSuffix(completedPath, "/") || strings.HasSuffix(completedPath, "\\") {
		fileName := currentDate + "_WCVS_Completed"
		completedPath += fileName
	}

	_, err := os.Stat(completedPath)

	var file *os.File
	defer file.Close()

	if !os.IsNotExist(err) {
		msg := fmt.Sprintf("The file %s will be overwritten, as it already exists\n", completedPath)
		pkg.PrintVerbose(msg, pkg.Yellow, 1)
		file, err = os.OpenFile(completedPath, os.O_WRONLY, 0666)
	} else {
		file, err = os.Create(completedPath)
	}
	if err != nil {
		msg := "CompletedURLs: " + err.Error() + "\n"
		pkg.PrintFatal(msg)
	}

	return file
}

/* Setting proxy with specified proxyURL and proxyCertPath */
func setProxy(proxyURLString string, proxyCertPath string) {
	proxyURL, err := url.Parse(proxyURLString)
	if err != nil {
		msg := "Proxy: " + err.Error() + "\n"
		pkg.PrintFatal(msg)
	}
	caCert, err := ioutil.ReadFile(proxyCertPath)
	if err != nil {
		msg := "Proxy: " + err.Error() + "\n"
		pkg.PrintFatal(msg)
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	tr := &http.Transport{
		Proxy: http.ProxyURL(proxyURL),
		TLSClientConfig: &tls.Config{
			RootCAs: caCertPool,
		}}

	err = http2.ConfigureTransport(tr)
	if err != nil {
		msg := fmt.Sprintf("Proxy: Cannot switch to HTTP2: %v\n", err)
		pkg.PrintFatal(msg)
	}

	http.DefaultTransport = tr
}
