package main

import (
	"crypto/tls"
	"crypto/x509"
	"flag"
	"io"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

var threads int
var verbose bool
var website *url.URL
var ogBody string
var ogCookies []*http.Cookie

func main() {
	/* Command-line flags */
	urlPtr := flag.String("url", "", "Url to scan")
	proxyCertPathPtr := flag.String("proxycertpath", "", "Path to the cert of the proxy you want to use")
	proxyURLPtr := flag.String("proxyurl", "http://127.0.0.1:8080", "Url for the proxy. Default value is http://127.0.0.1:8080")
	threadsPtr := flag.Int("threads", 20, "Threads to use. Default value is 20")
	timeOutPtr := flag.Int("timeout", 5, "Seconds until timeout. Default value is 5")
	topPtr := flag.Bool("topheaders", false, "Only test for most common headers.")
	verbosePtr := flag.Bool("verbose", false, "Verbose Output.")

	threads = *threadsPtr
	verbose = *verbosePtr

	flag.Parse()
	/*********************/

	/* Setting Logoutput to Log file and stdout */
	f, err := os.OpenFile("web-cache-poisoning-scanner.log", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	wrt := io.MultiWriter(f, os.Stdout)
	log.SetOutput(wrt)
	//if !verbose {log.SetOutput(f)}
	/******************************************/

	log.Println("Application started")
	start := time.Now()
	// Making the random generator really random
	rand.Seed(time.Now().UnixNano())

	/* Checking values of Flags */
	if len(flag.Args()) > 0 {
		log.Fatalln(flag.Args(), "Args are not supported! Use flags. Use -h or --help to get a list of all supported flags")
	}
	if *urlPtr == "" {
		log.Fatalln("No url specified. Use -url to specify one")
	}
	/***************************/

	/* Setting up proxy (e.g. burp), if wanted */
	if *proxyCertPathPtr != "" {
		setProxy(*proxyURLPtr, *proxyCertPathPtr)
	}
	/*******************************************/

	/* Getting response body and cookies from specified url */
	log.Println("Getting Body and Cookies")
	ogBody, ogCookies = getBodyAndCookies(*urlPtr)
	/********************************************************/

	/* Setting up client: cookies and noredirect */
	log.Println("Setting client")
	timeout := time.Duration(time.Duration(*timeOutPtr) * time.Second)
	website, err = url.Parse(*urlPtr)
	if err != nil {
		log.Fatalln(err)
	}
	jar, err := cookiejar.New(nil)
	if err != nil {
		log.Fatalln(err)
	}
	jar.SetCookies(website, ogCookies)

	clientNoRedir := http.Client{
		CheckRedirect: func(redirRequest *http.Request, via []*http.Request) error {
			log.Println("Redirect Request denied:", redirRequest.Header)
			return http.ErrUseLastResponse
		},
		Timeout: timeout,
		Jar:     jar,
	}
	/*******************************************/

	/* Check cookie for poisoning */
	log.Println("")
	log.Println("Checking cookies for poisoning")
	scanCookies(clientNoRedir)
	/*****************************/

	/* Check X-Forward-Scheme and X-Forward-Host for poisoning */
	log.Println("")
	log.Println("Check for X-Forward-Scheme X-Forward-Host poisoning")
	scanXForwardHeaders(clientNoRedir)
	/***********************************************************/

	/* Downloading header list or top header list */
	log.Println("")
	log.Println("Downloading header list")
	var headerListURL string
	if *topPtr {
		headerListURL = "https://raw.githubusercontent.com/Hackmanit/Web-Cache-Vulnerability-Scanner/master/resources/headers?token=ABBEYZ7JUDOQFR3YLO62Y3DAKIKZO"
	} else {
		headerListURL = "https://raw.githubusercontent.com/Hackmanit/Web-Cache-Vulnerability-Scanner/master/resources/topheaders?token=ABBEYZ27BSBMPAXZC2I3CMTAKIK72"
	}

	headerList, _ := getBodyAndCookies(headerListURL)
	headerListSplitted := strings.Split(headerList, "\n")
	/*********************************************/

	/* Checking headers for poisoning */
	log.Println("")
	log.Println("Testing now headers")
	scanHeaders(clientNoRedir, headerListSplitted)
	/*********************************/

	/* Scan finished */
	log.Println("")
	log.Println("Successfully finished the scan")

	duration := time.Since(start)
	log.Println("Duration:", duration)
	/****************/
}

/* Setting proxy with specified proxyURL and proxyCertPath */
func setProxy(proxyURLString string, proxyCertPath string) {
	proxyURL, err := url.Parse(proxyURLString)
	if err != nil {
		log.Fatal(err)
	}
	caCert, err := ioutil.ReadFile(proxyCertPath)
	if err != nil {
		log.Fatalln(err)
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	http.DefaultTransport = &http.Transport{
		Proxy: http.ProxyURL(proxyURL),
		TLSClientConfig: &tls.Config{
			RootCAs: caCertPool,
		}}
}

/* Simple get request to get the body of a normal response and the cookies */
func getBodyAndCookies(geturl string) (string, []*http.Cookie) {
	geturl = geturl + "?cb=" + randInt()
	resp, err := http.Get(geturl)
	if err != nil {
		log.Fatalln(err)
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	return string(body), resp.Cookies()
}

/* Create a random long integer */
func randInt() string {
	min := 100000000
	max := 999999999
	result := min + rand.Intn(max-min)
	return strconv.Itoa(result)
}

/* Scan cookies for poisoning */
func scanCookies(client http.Client) {
	for i := 0; i < len(ogCookies); i++ {
		poison := randInt()
		log.Println("Checking cookie", ogCookies[i].Name)

		oldValue := ogCookies[i].Value
		ogCookies[i].Value = poison
		client.Jar.SetCookies(website, ogCookies)

		cb := "?cb=" + randInt()
		req, err := http.NewRequest("GET", website.String()+cb, nil)
		if err != nil {
			log.Fatalln(err)
		}

		resp, err := client.Do(req)
		if err != nil {
			log.Fatalln(err)
		}

		defer resp.Body.Close()

		bodyPoison, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		ogCookies[i].Value = oldValue
		client.Jar.SetCookies(website, ogCookies)

		//TODO: Compare (at first) ContentLength instead of whole body?
		if string(bodyPoison) == ogBody {
			continue
		}

		req, err = http.NewRequest("GET", website.String()+cb, nil)
		if err != nil {
			log.Fatalln(err)
		}

		resp, err = client.Do(req)
		if err != nil {
			log.Fatalln(err)
		}

		defer resp.Body.Close()

		bodyVictim, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		if strings.Contains(string(bodyVictim), poison) {
			log.Println("")
			log.Println("-------", ogCookies[i], "was successfully poisoned!!!", cb, "poison:", poison, "-------")
		}
	}
}

/* Scan X-Forward headers for poisoning */
func scanXForwardHeaders(client http.Client) {
	poison := randInt()

	cb := "?cb=" + randInt()
	req, err := http.NewRequest("GET", website.String()+cb, nil)
	if err != nil {
		log.Fatalln(err)
	}
	req.Header.Add("X-Forwarded-Host", poison)
	req.Header.Add("X-Forwarded-Scheme", "nothttps")

	resp, err := client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}

	req.Header.Del("X-Forwarded-Host")
	req.Header.Del("X-Forwarded-Scheme")

	//TODO: Check first request, if second is necessary?
	req, err = http.NewRequest("GET", website.String()+cb, nil)
	if err != nil {
		log.Fatalln(err)
	}

	resp, err = client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}
	if strings.Contains(resp.Header.Get("Location"), poison) || strings.Contains(req.Host, poison) {
		log.Println("")
		log.Println("------- X-Forwarded-Host and X-Forwarded-Scheme was successfully poisoned!!!", cb, "poison:", poison, "-------")
	}
}

/* Scan headers for poisoning */
func scanHeaders(client http.Client, headerListSplitted []string) {
	//c := make(chan result) //<- needed?
	var wg sync.WaitGroup

	for i, s := range headerListSplitted {
		if s == "" {
			continue
		}

		if (i+1)%threads == 0 {
			wg.Wait()
		}
		wg.Add(1)

		poison := randInt()

		go func(i int, s string, poison string) {
			defer wg.Done()

			if verbose {
				log.Println("Testing now", i, s)
			}

			cb := "?cb=" + randInt()
			req, err := http.NewRequest("GET", website.String()+cb, nil)
			if err != nil {
				log.Fatalln(err)
			}
			req.Header.Add(s, poison)

			resp, err := client.Do(req)
			if err != nil {
				log.Println(err)
				req.Header.Del(s)
				return
			}

			req.Header.Del(s)

			defer resp.Body.Close()
			bodyPoison, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				log.Fatalln(err)
			}

			if string(bodyPoison) == ogBody {
				return
			}

			req, err = http.NewRequest("GET", website.String()+cb, nil)
			if err != nil {
				log.Fatalln(err)
			}

			resp, err = client.Do(req)
			if err != nil {
				log.Fatalln(err)
			}

			defer resp.Body.Close()
			bodyVictim, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				log.Fatalln(err)
			}

			if strings.Contains(string(bodyVictim), poison) {
				log.Println("")
				log.Println("-------", s, "was successfully poisoned!!!", cb, "poison:", poison, "-------")
			}
		}(i, s, poison)

	}
	wg.Wait()
}
