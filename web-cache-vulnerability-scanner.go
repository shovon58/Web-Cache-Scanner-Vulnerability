package main

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"golang.org/x/net/http2"

	"github.com/Hackmanit/Web-Cache-Vulnerability-Scanner/v2/pkg"
)

/*
Build module

go get ./...

sudo /usr/local/go/bin/go clean -cache -modcache -i -r

go mod tidy

env GOOS=windows GOARCH=amd64 go build
go build
set GOOS=
set GOARCH=
go build
*/

const version = "1.0.0"

var config pkg.Config
var report pkg.Report

func main() {
	/* Hier die config datei einlesen */
	/* Hier dann die config aus den flags einlesen */
	//config = pkg.ReadConfigFile()
	config = pkg.ParseFlags(config, version)
	/*****************************/

	/**** SET EXPORT STRUCT ****/
	report.Name = "Web_Cache_Vulnerability_Scanner"
	report.Version = version

	report.Config = &config
	/***************************/

	// Check config if Log shall be printed or no logs shall be made
	/* Setting Logoutput to Log file and stdout */
	f, err := os.OpenFile("web-cache-poisoning-scanner.log", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	//wrt := io.MultiWriter(f, os.Stdout)
	//log.SetOutput(wrt)
	log.SetOutput(f)
	/******************************************/

	msg := "Application started\n"
	pkg.PrintVerbose(msg, config.Verbosity, 2)

	start := time.Now()
	// Making the random generator really random
	rand.Seed(time.Now().UnixNano())

	noTestPreference := true
	if config.DoTest != "" && config.DontTest != "" {
		msg = "You can't set both doTest and dontTest\n"
		pkg.PrintFatal(msg)
	} else if config.DoTest != "" {
		noTestPreference = false
	} else if config.DontTest != "" {
		noTestPreference = false
	}
	/***************************/

	/* Setting up proxy (e.g. burp), if wanted */
	if config.ProxyCertPath != "" {
		setProxy(config.ProxyURL, config.ProxyCertPath)
	}
	/*******************************************/

	// Reading header wordlist, only if it is needed
	var headerList []string
	if noTestPreference || strings.Contains(config.DoTest, "header") || (config.DontTest != "" && !strings.Contains(config.DontTest, "header")) {
		headerList = pkg.ReadLocalFile(config.HeaderWordlist)
	}

	// Reading parameter wordlist, only if it is needed
	var parameterList []string
	if noTestPreference || strings.Contains(config.DoTest, "parameter") || (config.DontTest != "" && !strings.Contains(config.DontTest, "parameter")) {
		parameterList = pkg.ReadLocalFile(config.QueryWordlist)
	}
	/*******************************************************/

	//config.Website.Added = make(map[string]bool)
	added := make(map[string]bool)

	var testUrls []string
	for _, u := range config.Urls {
		u = strings.TrimSuffix(u, "\r")
		u = strings.TrimSpace(u)

		// check if empty or is a comment
		if u == "" || strings.HasPrefix(u, "//") {
			continue
		}

		added[u] = true
		testUrls = append(testUrls, u)
	}

	for rec := 0; rec <= config.Recursivity; rec++ {
		var foundUrls []string

		for i, u := range testUrls {

			fmt.Printf("-----------------------------------------------------------------------\n")
			msg := fmt.Sprintf("Testing now website(%d/%d): %s\n", i+1, len(testUrls), u)
			pkg.PrintVerbose(msg, config.Verbosity, 0)
			fmt.Printf("-----------------------------------------------------------------------\n")

			/* Setting up client: cookies and noredirect */
			msg = "Setting up client\n"
			pkg.PrintVerbose(msg, config.Verbosity, 2)

			// Setting cookies, speficied by setcookies
			config.Website.Cookies = []*http.Cookie{}
			for _, c := range config.Cookies {
				c = strings.TrimSuffix(c, "\r")
				c = strings.TrimSpace(c)
				if c == "" {
					continue
				} else if !strings.Contains(c, "=") {
					msg = "Specified cookie %s doesn't contain a = and will be skipped\n"
					pkg.PrintVerbose(msg, config.Verbosity, 2)
					continue
				} else {
					cSlice := strings.SplitAfterN(c, "=", 2)
					cSlice[0] = strings.TrimSuffix(cSlice[0], "=")

					cookie := http.Cookie{
						Name:  cSlice[0],
						Value: cSlice[1],
					}
					config.Website.Cookies = append(config.Website.Cookies, &cookie)
				}
			}

			timeOutDuration := time.Duration(time.Duration(config.TimeOut) * time.Second)
			clientNoRedir := http.Client{
				CheckRedirect: func(redirRequest *http.Request, via []*http.Request) error {
					msg := fmt.Sprintf("Redirect Request denied: %s\n", redirRequest.Header)
					pkg.PrintVerbose(msg, config.Verbosity, 2)
					return http.ErrUseLastResponse
				},
				Timeout: timeOutDuration,
			}

			// retrieve cookies
			config.Website = pkg.GetWebsite(u, clientNoRedir, config.RetrieveCookies, true, config)

			if config.RetrieveCookies {
				// retrieve response with all cookies set
				config.Website = pkg.GetWebsite(u, clientNoRedir, config.RetrieveCookies, false, config)
			}

			// check if there's a cache and the cachebuster works
			config.Website.Cache = pkg.CheckCache(clientNoRedir, config)
			/*******************************************/

			/* Check cookie for poisoning */
			if noTestPreference || strings.Contains(config.DoTest, "cookie") || (config.DontTest != "" && !strings.Contains(config.DontTest, "cookie")) {
				msg = "Testing for cookie poisoning\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)

				report.Results = append(report.Results, pkg.ScanCookies(clientNoRedir, config))

				if len(config.Website.Cookies) == 0 {
					errMsg := "There were no cookies to test!"
					pkg.PrintVerbose(pkg.Yellow+errMsg+"\n"+pkg.Reset, config.Verbosity, 0)

					report.Results[len(report.Results)-1].ErrorMessage = errMsg
					report.Results[len(report.Results)-1].HasError = true
				}
			} else {
				msg = "Skipping to test for cookie poisoning\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)

			}
			/*****************************/

			/* Check X-Forwarded-Scheme and X-Forwarded-Host for poisoning */
			if noTestPreference || strings.Contains(config.DoTest, "forward") || (config.DontTest != "" && !strings.Contains(config.DontTest, "forward")) {
				msg = "Testing for X-Forwarded-Scheme X-Forwarded-Host poisoning\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)

				report.Results = append(report.Results, pkg.ScanXForwardHeaders(clientNoRedir, config))
			} else {
				msg = "Skipping to test for X-Forwarded-Scheme X-Forwarded-Host poisoning\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)
			}
			/***********************************************************/

			/* Checking headers for poisoning */
			if noTestPreference || strings.Contains(config.DoTest, "header") || (config.DontTest != "" && !strings.Contains(config.DontTest, "header")) {
				msg = "Testing for header poisoning\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)

				report.Results = append(report.Results, pkg.ScanHeaders(clientNoRedir, headerList, config))
			} else {
				msg = "Skipping to test for header poisoning\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)
			}
			/*********************************/

			/* Checking query parameters for poisoning */
			if noTestPreference || strings.Contains(config.DoTest, "parameter") || (config.DontTest != "" && !strings.Contains(config.DontTest, "parameter")) {
				msg = "Testing for query parameter poisoning\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)
				report.Results = append(report.Results, pkg.ScanParameters(clientNoRedir, parameterList, config))
			} else {
				msg = "Skipping to test for query parameter poisoning\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)
			}
			/*******************************************/

			/* Trying fat GET technique */
			if config.DoPost {
				msg = "Can't check for Fat GET, because POST was specified\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)
			} else if noTestPreference || strings.Contains(config.DoTest, "fat") || (config.DontTest != "" && !strings.Contains(config.DontTest, "fat")) {
				msg = "Testing for Fat GET\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)

				report.Results = append(report.Results, pkg.ScanFatGET(clientNoRedir, config))
			} else {
				msg = "Skipping to test for Fat GET\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)
			}
			/****************************/

			/* Trying Parameter Cloaking technique */
			if config.DoPost {
				msg = "Can't check for Parameter Cloaking, because POST was specified\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)
			} else if noTestPreference || strings.Contains(config.DoTest, "cloaking") || (config.DontTest != "" && !strings.Contains(config.DontTest, "cloaking")) {
				msg = "Testing for Parameter Cloaking\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)

				report.Results = append(report.Results, pkg.ScanParameterCloaking(clientNoRedir, config))
			} else {
				msg = "Skipping to test for Parameter Cloaking\n"
				pkg.PrintVerbose(msg, config.Verbosity, 1)
			}
			/***************************************/

			/* Check for linked files */
			if config.Recursivity > rec {
				msg = fmt.Sprintf("Checking recursively for urls (%d/%d)\n", rec+1, config.Recursivity)
				pkg.PrintVerbose(msg, config.Verbosity, 0)

				tempUrls := pkg.CrawlUrls(config, added)

				if len(tempUrls) > 0 {
					msg = fmt.Sprintf("Found %d urls", len(tempUrls))
					pkg.PrintVerbose(msg, config.Verbosity, 0)

					msg = ". Adding the following urls to the Queue:"
					pkg.PrintVerbose(msg, config.Verbosity, 1)
					pkg.PrintVerbose("\n", config.Verbosity, 0)
					for _, u := range tempUrls {
						pkg.PrintVerbose(u, config.Verbosity, 1)
					}

					foundUrls = append(foundUrls, tempUrls...)
				} else {
					pkg.PrintVerbose(msg, config.Verbosity, 0)
					log.Println("No urls were found to add to the queue")
				}
			}
			/**************************/
		}
		if config.Recursivity > 0 && len(foundUrls) == 0 {
			msg = "No more urls found to check!"
			pkg.PrintVerbose(msg, config.Verbosity, 0)
			break
		}
		testUrls = foundUrls
	}

	/* Scan finished */
	msg = "Successfully finished the scan\n"
	pkg.PrintVerbose(msg, config.Verbosity, 1)

	duration := time.Since(start)
	msg = fmt.Sprintf("Duration: %s\n\n", duration)
	pkg.PrintVerbose(msg, config.Verbosity, 1)

	if config.GenerateReport {
		report.Vulnerable = len(report.Results) > 0
		report.Date = time.Now().Format("2006-01-02_15:04:05")
		report.Duration = duration.String()
		pkg.ExportReport(report, config.EscapeJSON)
	}
	/****************/
}

/* Setting proxy with specified proxyURL and proxyCertPath */
func setProxy(proxyURLString string, proxyCertPath string) {
	proxyURL, err := url.Parse(proxyURLString)
	if err != nil {
		pkg.PrintFatal(err.Error())
	}
	caCert, err := ioutil.ReadFile(proxyCertPath)
	if err != nil {
		pkg.PrintFatal(err.Error())
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	tr := &http.Transport{
		Proxy: http.ProxyURL(proxyURL),
		TLSClientConfig: &tls.Config{
			RootCAs: caCertPool,
		}}

	err = http2.ConfigureTransport(tr)
	if err != nil {
		msg := fmt.Sprintf("Cannot switch to HTTP2: %v\n", err)
		pkg.PrintFatal(msg)
	}

	http.DefaultTransport = tr
}
