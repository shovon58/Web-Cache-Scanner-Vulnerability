package main

import (
	"crypto/tls"
	"crypto/x509"
	"flag"
	"io"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

var threads int
var verbose bool

var website Website
var givenHeaders map[string]string
var givenParameters map[string]string

var headersURL string
var parametersURL string
var topHeadersURL string
var topParametersURL string

type Website struct {
	Body    string
	Cookies []*http.Cookie
	Status  string
	Url     *url.URL
}

func main() {
	/* Setting hardcoded global vars */
	headersURL = "https://raw.githubusercontent.com/m10x/wordlists/master/headers"
	parametersURL = "https://raw.githubusercontent.com/m10x/wordlists/master/parameters"
	topHeadersURL = "https://raw.githubusercontent.com/m10x/wordlists/master/top-headers"
	topParametersURL = "https://raw.githubusercontent.com/m10x/wordlists/master/top-parameters"
	/*********************************/

	/* Getting Command-line flags */
	headerWordlist := flag.String("headerWordlist", "", "Wordlist for headers to test. Use 'path:' or 'url:'")
	//headersPath
	parameterWordlist := flag.String("parameterWordlist", "", "Wordlist for query parameters to test. Use 'path:' or 'url:'")
	//parametersPath
	urlPtr := flag.String("url", "", "Url to scan")
	proxyCertPathPtr := flag.String("proxycertpath", "", "Path to the cert of the proxy you want to use")
	proxyURLPtr := flag.String("proxyurl", "http://127.0.0.1:8080", "Url for the proxy. Default value is http://127.0.0.1:8080")
	threadsPtr := flag.Int("threads", 20, "Threads to use. Default value is 20")
	timeOutPtr := flag.Int("timeout", 5, "Seconds until timeout. Default value is 5")
	topHeadersPtr := flag.Bool("topheaders", false, "Only test for most common headers.")
	topParametersPtr := flag.Bool("topparameters", false, "Only test for most common query parameters.")
	verbosePtr := flag.Bool("verbose", false, "Verbose Output.")

	threads = *threadsPtr
	verbose = *verbosePtr

	flag.Parse()
	/*****************************/

	/* Setting Logoutput to Log file and stdout */
	f, err := os.OpenFile("web-cache-poisoning-scanner.log", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	wrt := io.MultiWriter(f, os.Stdout)
	log.SetOutput(wrt)
	//if !verbose {log.SetOutput(f)}
	/******************************************/

	log.Println("Application started")
	start := time.Now()
	// Making the random generator really random
	rand.Seed(time.Now().UnixNano())

	/* Checking values of Flags */
	if len(flag.Args()) > 0 {
		log.Fatalln(flag.Args(), "Args are not supported! Use flags. Use -h or --help to get a list of all supported flags")
	}
	if *urlPtr == "" {
		log.Fatalln("No url specified. Use -url to specify one")
	}
	/***************************/

	/* Setting up proxy (e.g. burp), if wanted */
	if *proxyCertPathPtr != "" {
		setProxy(*proxyURLPtr, *proxyCertPathPtr)
	}
	/*******************************************/

	/* Reading parameter and header wordlist, if specified */

	/*******************************************************/

	/* Splitting URLs from parameter */
	urls := strings.Split(*urlPtr, ",")

	for i, u := range urls {

		website = getWebsite(u)

		log.Println("-----------------------------------------------------------------------")
		log.Println("Testing now website(", i+1, "/", len(urls), "):", website.Url)
		/* Setting up client: cookies and noredirect */
		log.Println("Setting up client")
		timeout := time.Duration(time.Duration(*timeOutPtr) * time.Second)
		//websiteUrl := website.Url

		jar, err := cookiejar.New(nil)
		if err != nil {
			log.Fatalln(err)
		}
		jar.SetCookies(website.Url, website.Cookies)

		clientNoRedir := http.Client{
			CheckRedirect: func(redirRequest *http.Request, via []*http.Request) error {
				log.Println("Redirect Request denied:", redirRequest.Header)
				return http.ErrUseLastResponse
			},
			Timeout: timeout,
			Jar:     jar,
		}
		/*******************************************/

		/* Check cookie for poisoning */
		log.Println()
		log.Println("Checking cookies for poisoning")
		scanCookies(clientNoRedir)
		/*****************************/

		/* Check X-Forward-Scheme and X-Forward-Host for poisoning */
		log.Println()
		log.Println("Check for X-Forward-Scheme X-Forward-Host poisoning")
		scanXForwardHeaders(clientNoRedir)
		/***********************************************************/

		/* Downloading header list or top header list */

		/*********************************************/

		/* Checking headers for poisoning */
		log.Println()
		log.Println("Testing now headers")
		headerList := downloadWordlist("headers", *topHeadersPtr)
		scanHeaders(clientNoRedir, headerList)
		/*********************************/

		/* Checking query parameters for poisoning */
		log.Println()
		log.Println("Testing now query parameters")
		parameterList := downloadWordlist("parameters", *topParametersPtr)
		scanParameters(clientNoRedir, parameterList)
		/*******************************************/

		/* Trying FAT-GET technique */
		log.Println()
		log.Println("Testing for FAT-GET")
		//scanFATGET(clientNoRedir)
		/****************************/
	}

	/* Scan finished */
	log.Println()
	log.Println("Successfully finished the scan")

	duration := time.Since(start)
	log.Println("Duration:", duration)
	/****************/
}

/* Setting proxy with specified proxyURL and proxyCertPath */
func setProxy(proxyURLString string, proxyCertPath string) {
	proxyURL, err := url.Parse(proxyURLString)
	if err != nil {
		log.Fatal(err)
	}
	caCert, err := ioutil.ReadFile(proxyCertPath)
	if err != nil {
		log.Fatalln(err)
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	http.DefaultTransport = &http.Transport{
		Proxy: http.ProxyURL(proxyURL),
		TLSClientConfig: &tls.Config{
			RootCAs: caCertPool,
		}}
}

/* Simple get request to get the body of a normal response and the cookies */
func getWebsite(geturl string) Website {
	requrl := geturl + "?cb=" + randInt()
	resp, err := http.Get(requrl)
	if err != nil {
		log.Fatalln(err)
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	weburl, err := url.Parse(geturl)
	if err != nil {
		log.Fatalln(err)
	}

	c := Website{
		Body:    string(body),
		Cookies: resp.Cookies(),
		Status:  resp.Status,
		Url:     weburl,
	}

	return c
}

/* Create a random long integer */
func randInt() string {
	min := 100000000
	max := 999999999
	result := min + rand.Intn(max-min)
	return strconv.Itoa(result)
}

/* Scan cookies for poisoning */
func scanCookies(client http.Client) {
	for i := 0; i < len(website.Cookies); i++ {
		poison := randInt()
		log.Println("Checking cookie", website.Cookies[i].Name)

		oldValue := website.Cookies[i].Value
		website.Cookies[i].Value = poison
		client.Jar.SetCookies(website.Url, website.Cookies)

		cb := "?cb=" + randInt()
		req, err := http.NewRequest("GET", website.Url.String()+cb, nil)
		if err != nil {
			log.Fatalln(err)
		}

		resp, err := client.Do(req)
		if err != nil {
			log.Fatalln(err)
		}

		defer resp.Body.Close()

		bodyPoison, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		website.Cookies[i].Value = oldValue
		client.Jar.SetCookies(website.Url, website.Cookies)

		//TODO: Compare (at first) ContentLength instead of whole body?
		if string(bodyPoison) == website.Body {
			continue
		}

		req, err = http.NewRequest("GET", website.Url.String()+cb, nil)
		if err != nil {
			log.Fatalln(err)
		}

		resp, err = client.Do(req)
		if err != nil {
			log.Fatalln(err)
		}

		defer resp.Body.Close()

		bodyVictim, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		if strings.Contains(string(bodyVictim), poison) {
			log.Println("")
			log.Println("-------", website.Cookies[i], "was successfully poisoned!!!", cb, "poison:", poison, "-------")
		}
	}
}

/* Scan X-Forward headers for poisoning */
func scanXForwardHeaders(client http.Client) {
	poison := randInt()

	cb := "?cb=" + randInt()
	req, err := http.NewRequest("GET", website.Url.String()+cb, nil)
	if err != nil {
		log.Fatalln(err)
	}
	req.Header.Add("X-Forwarded-Host", poison)
	req.Header.Add("X-Forwarded-Scheme", "nothttps")

	resp, err := client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}

	req.Header.Del("X-Forwarded-Host")
	req.Header.Del("X-Forwarded-Scheme")

	//TODO: Check first request, if second is necessary?
	req, err = http.NewRequest("GET", website.Url.String()+cb, nil)
	if err != nil {
		log.Fatalln(err)
	}

	resp, err = client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}
	if strings.Contains(resp.Header.Get("Location"), poison) || strings.Contains(req.Host, poison) {
		log.Println("")
		log.Println("------- X-Forwarded-Host and X-Forwarded-Scheme was successfully poisoned!!!", cb, "poison:", poison, "-------")
	}
}

/* Download a list and split it */
func downloadWordlist(listtype string, top bool) []string {
	var wordlistURL string
	log.Println("")
	if listtype == "headers" {
		log.Println("Downloading header list")
		if top {
			wordlistURL = topHeadersURL
		} else {
			wordlistURL = headersURL
		}
	} else if listtype == "parameters" {
		log.Println("Downloading header list")
		if top {
			wordlistURL = topParametersURL
		} else {
			wordlistURL = parametersURL
		}
	} else {
		log.Fatalln("'" + listtype + "' is not a valid parameter for the method downloadWordlist")
	}

	wordlist := getWebsite(wordlistURL)
	return strings.Split(wordlist.Body, "\n")
}

/* Scan headers for poisoning */
func scanHeaders(client http.Client, headerList []string) {
	//c := make(chan result) //<- needed?
	var wg sync.WaitGroup

	for i, s := range headerList {
		if s == "" {
			continue
		}

		// wait if max thread count is reached
		if (i+1)%threads == 0 {
			wg.Wait()
		}
		wg.Add(1)

		poison := randInt()

		go func(i int, s string, poison string) {
			defer wg.Done()

			if verbose {
				log.Println("Testing now", i, s)
			}

			cb := "?cb=" + randInt()
			req, err := http.NewRequest("GET", website.Url.String()+cb, nil)
			if err != nil {
				log.Fatalln(err)
			}
			req.Header.Add(s, poison)

			resp, err := client.Do(req)
			if err != nil {
				log.Println(err)
				req.Header.Del(s)
				return
			}

			req.Header.Del(s)

			defer resp.Body.Close()
			bodyPoison, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				log.Fatalln(err)
			}

			if string(bodyPoison) == website.Body {
				return
			}

			req, err = http.NewRequest("GET", website.Url.String()+cb, nil)
			if err != nil {
				log.Fatalln(err)
			}

			resp, err = client.Do(req)
			if err != nil {
				log.Fatalln(err)
			}

			defer resp.Body.Close()
			bodyVictim, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				log.Fatalln(err)
			}

			if strings.Contains(string(bodyVictim), poison) {
				log.Println("")
				log.Println("-------", s, "was successfully poisoned!!!", cb, "poison:", poison, "-------")
			}
		}(i, s, poison)

	}
	wg.Wait()
}

/* Scan query parameters for poisoning */
func scanParameters(client http.Client, parameterList []string) {
	//c := make(chan result) //<- needed?
	var wg sync.WaitGroup

	for i, s := range parameterList {
		if s == "" {
			continue
		}

		// wait if max thread count is reached
		if (i+1)%threads == 0 {
			wg.Wait()
		}
		wg.Add(1)

		poison := randInt()

		go func(i int, s string, poison string) {
			defer wg.Done()

			if verbose {
				log.Println("Testing now", i, s)
			}

			cb := "?cb=" + randInt()
			req, err := http.NewRequest("GET", website.Url.String()+cb+"&"+s+"="+poison, nil)
			if err != nil {
				log.Fatalln(err)
			}

			resp, err := client.Do(req)
			if err != nil {
				log.Println(err)
				return
			}

			//req.Header.Del(s)

			defer resp.Body.Close()
			bodyPoison, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				log.Fatalln(err)
			}

			if string(bodyPoison) == website.Body {
				return
			}

			req, err = http.NewRequest("GET", website.Url.String()+cb, nil)
			if err != nil {
				log.Fatalln(err)
			}

			resp, err = client.Do(req)
			if err != nil {
				log.Fatalln(err)
			}

			defer resp.Body.Close()
			bodyVictim, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				log.Fatalln(err)
			}

			if strings.Contains(string(bodyVictim), poison) {
				log.Println("")
				log.Println("-------", s, "was successfully poisoned!!!", cb, "poison:", poison, "-------")
			}
		}(i, s, poison)

	}
	wg.Wait()
}

/* Check for FAT-GET */
func scanFATGET(client http.Client) {
	var wg sync.WaitGroup

	wg.Add(1)
	poison := randInt()
	go func(poison string) {
		defer wg.Done()

		if verbose {
			log.Println("Testing now simple FAT-GET")
		}

		cb := "?cb=" + randInt()
		req, err := http.NewRequest("GET", website.Url.String()+cb, nil)
		if err != nil {
			log.Fatalln(err)
		}

		resp, err := client.Do(req)
		if err != nil {
			log.Println(err)
			return
		}

		//req.Header.Del(s)

		defer resp.Body.Close()
		bodyPoison, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		if string(bodyPoison) == website.Body {
			return
		}

		req, err = http.NewRequest("GET", website.Url.String()+cb, nil)
		if err != nil {
			log.Fatalln(err)
		}

		resp, err = client.Do(req)
		if err != nil {
			log.Fatalln(err)
		}

		defer resp.Body.Close()
		bodyVictim, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}

		if strings.Contains(string(bodyVictim), poison) {
			log.Println("")
			log.Println("------- FAT-GET was successfully poisoned!!!", cb, "poison:", poison, "-------")
		}
	}(poison)
}
