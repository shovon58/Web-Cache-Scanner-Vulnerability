package main

import (
	"crypto/tls"
	"crypto/x509"
	"io"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/Hackmanit/Web-Cache-Vulnerability-Scanner/v2/pkg"
)

/*
Build module

go get ./...

go clean -cache -modcache -i -r

env GOOS=windows GOARCH=amd64 go build
go build
set GOOS=
set GOARCH=
go build
*/

const version = "1.0.0"

var config pkg.Config
var report pkg.Report

func main() {
	/* Hier die config datei einlesen */
	/* Hier dann die config aus den flags einlesen */
	//config = pkg.ReadConfigFile()
	config = pkg.ParseFlags(config, version)
	/*****************************/

	/**** SET EXPORT STRUCT ****/
	report.Name = "Web_Cache_Vulnerability_Scanner"
	report.Version = version

	report.Config = &config
	/***************************/

	// Check config if Log shall be printed or no logs shall be made
	/* Setting Logoutput to Log file and stdout */
	f, err := os.OpenFile("web-cache-poisoning-scanner.log", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	wrt := io.MultiWriter(f, os.Stdout)
	log.SetOutput(wrt)
	//if !verbose {log.SetOutput(f)}
	/******************************************/

	log.Println("Application started")
	start := time.Now()
	// Making the random generator really random
	rand.Seed(time.Now().UnixNano())

	noTestPreference := true
	if config.DoTest != "" && config.DontTest != "" {
		log.Fatalln("You can't set both doTest and dontTest")
	} else if config.DoTest != "" {
		noTestPreference = false
	} else if config.DontTest != "" {
		noTestPreference = false
	}
	/***************************/

	/* Setting up proxy (e.g. burp), if wanted */
	if config.ProxyCertPath != "" {
		setProxy(config.ProxyURL, config.ProxyCertPath)
	}
	/*******************************************/

	// Reading header wordlist, only if it is needed
	var headerList []string
	if noTestPreference || strings.Contains(config.DoTest, "header") || (config.DontTest != "" && !strings.Contains(config.DontTest, "header")) {
		headerList = pkg.ReadLocalFile(config.HeaderWordlist)
	}

	// Reading parameter wordlist, only if it is needed
	var parameterList []string
	if noTestPreference || strings.Contains(config.DoTest, "parameter") || (config.DontTest != "" && !strings.Contains(config.DontTest, "parameter")) {
		parameterList = pkg.ReadLocalFile(config.QueryWordlist)
	}
	/*******************************************************/

	//config.Website.Added = make(map[string]bool)
	added := make(map[string]bool)

	var testUrls []string
	for _, u := range config.Urls {
		u = strings.TrimSuffix(u, "\r")
		u = strings.TrimSpace(u)

		// check if empty or is a comment
		if u == "" || strings.HasPrefix(u, "//") {
			continue
		}

		added[u] = true
		testUrls = append(testUrls, u)
	}

	for rec := 0; rec <= config.Recursivity; rec++ {
		var foundUrls []string

		for i, u := range testUrls {

			log.Println("")
			log.Println("-----------------------------------------------------------------------")
			log.Printf("Testing now website(%d/%d): %s\n", i+1, len(testUrls), u)
			log.Println("-----------------------------------------------------------------------")

			/* Setting up client: cookies and noredirect */
			if config.Verbosity >= 1 {
				log.Println("Setting up client")
			}

			// Setting cookies, speficied by setcookies
			config.Website.Cookies = []*http.Cookie{}
			for _, c := range config.Cookies {
				c = strings.TrimSuffix(c, "\r")
				c = strings.TrimSpace(c)
				if c == "" {
					continue
				} else if !strings.Contains(c, "=") {
					log.Printf("Specified cookie %s doesn't contain a = and will be skipped\n", c)
					continue
				} else {
					cSlice := strings.SplitAfterN(c, "=", 2)
					cSlice[0] = strings.TrimSuffix(cSlice[0], "=")

					cookie := http.Cookie{
						Name:  cSlice[0],
						Value: cSlice[1],
					}
					config.Website.Cookies = append(config.Website.Cookies, &cookie)
				}
			}

			timeOutDuration := time.Duration(time.Duration(config.TimeOut) * time.Second)
			clientNoRedir := http.Client{
				CheckRedirect: func(redirRequest *http.Request, via []*http.Request) error {
					log.Printf("Redirect Request denied: %s\n", redirRequest.Header)
					return http.ErrUseLastResponse
				},
				Timeout: timeOutDuration,
			}

			// retrieve cookies
			config.Website = pkg.GetWebsite(u, clientNoRedir, config.RetrieveCookies, true, config)

			if config.RetrieveCookies {
				// retrieve response with all cookies set
				config.Website = pkg.GetWebsite(u, clientNoRedir, config.RetrieveCookies, false, config)
			}

			// check if there's a cache and the cachebuster works
			config.Website.Cache = pkg.CheckCache(clientNoRedir, config)
			/*******************************************/

			/* Check cookie for poisoning */
			if noTestPreference || strings.Contains(config.DoTest, "cookie") || (config.DontTest != "" && !strings.Contains(config.DontTest, "cookie")) {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Checking cookies for poisoning")
				}
				report.Results = append(report.Results, pkg.ScanCookies(clientNoRedir, config))
			} else {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Skipping to check cookies")
				}
			}
			/*****************************/

			/* Check X-Forwarded-Scheme and X-Forwarded-Host for poisoning */
			if noTestPreference || strings.Contains(config.DoTest, "forward") || (config.DontTest != "" && !strings.Contains(config.DontTest, "forward")) {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Checking for X-Forwarded-Scheme X-Forwarded-Host poisoning")
				}
				pkg.ScanXForwardHeaders(clientNoRedir, config)
			} else {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Skipping to check forward")
				}
			}
			/***********************************************************/

			/* Checking headers for poisoning */
			if noTestPreference || strings.Contains(config.DoTest, "header") || (config.DontTest != "" && !strings.Contains(config.DontTest, "header")) {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Testing now headers")
				}
				pkg.ScanHeaders(clientNoRedir, headerList, config)
			} else {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Skipping to check headers")
				}
			}
			/*********************************/

			/* Checking query parameters for poisoning */
			if noTestPreference || strings.Contains(config.DoTest, "parameter") || (config.DontTest != "" && !strings.Contains(config.DontTest, "parameter")) {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Testing now query parameters")
				}
				pkg.ScanParameters(clientNoRedir, parameterList, config)
			} else {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Skipping to check query parameters")
				}
			}
			/*******************************************/

			/* Trying fat GET technique */
			if config.DoPost {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Can't check for Fat GET, because POST was specified")
				}
			} else if noTestPreference || strings.Contains(config.DoTest, "fatget") || (config.DontTest != "" && !strings.Contains(config.DontTest, "fatget")) {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Testing for Fat GET")
					pkg.ScanFatGET(clientNoRedir, config)
				}
			} else {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Skipping to check Fat GET")
				}
			}
			/****************************/

			/* Trying Parameter Cloaking technique */
			if config.DoPost {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Can't check for Parameter Cloaking, because POST was specified")
				}
			} else if noTestPreference || strings.Contains(config.DoTest, "cloaking") || (config.DontTest != "" && !strings.Contains(config.DontTest, "cloaking")) {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Testing for Parameter Cloaking")
					pkg.ScanParameterCloaking(clientNoRedir, config)
				}
			} else {
				if config.Verbosity >= 1 {
					log.Println()
					log.Println("Skipping to check Parameter Cloaking")
				}
			}
			/***************************************/

			/* Check for linked files */
			if config.Recursivity > rec {
				log.Printf("Checking recursively for urls (%d/%d)\n", rec+1, config.Recursivity)

				tempUrls := pkg.CrawlUrls(config, added)

				if len(tempUrls) > 0 {
					log.Printf("Found %d urls. Adding the following urls to the Queue", len(tempUrls))

					for _, u := range tempUrls {
						log.Println(u)
					}

					foundUrls = append(foundUrls, tempUrls...)
				} else {
					log.Println("No urls were found to add to the queue")
				}
			}
			/**************************/
		}
		if len(foundUrls) == 0 {
			log.Println()
			log.Println("No more urls found to check!")
			break
		}
		testUrls = foundUrls
	}

	/* Scan finished */
	log.Println()
	log.Println("Successfully finished the scan")

	duration := time.Since(start)
	log.Printf("Duration: %s\n\n", duration)

	if config.GenerateReport {
		report.Vulnerable = len(report.Results) > 0
		report.Date = time.Now().Format("01-02-2006_15:04:05")
		report.Duration = duration.String()
		pkg.ExportReport(report)
	}
	/****************/
}

/* Setting proxy with specified proxyURL and proxyCertPath */
func setProxy(proxyURLString string, proxyCertPath string) {
	proxyURL, err := url.Parse(proxyURLString)
	if err != nil {
		log.Fatal(err)
	}
	caCert, err := ioutil.ReadFile(proxyCertPath)
	if err != nil {
		log.Fatalln(err)
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	http.DefaultTransport = &http.Transport{
		Proxy: http.ProxyURL(proxyURL),
		TLSClientConfig: &tls.Config{
			RootCAs: caCertPool,
		}}
}
