package pkg

import (
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/http/httputil"
	"strings"

	"moul.io/http2curl"
)

func TestWebCacheDeception() reportResult {
	var repResult reportResult
	repResult.Technique = "Cache Deception"

	// cacheable extensions: class, css, jar, js, jpg, jpeg, gif, ico, png, bmp, pict, csv, doc, docx, xls, xlsx, ps, pdf, pls, ppt, pptx, tif, tiff, ttf, otf, webp, woff, woff2, svg, svgz, eot, eps, ejs, swf, torrent, midi, mid
	appendings := []string{
		"/.css",
		"/nonexistent.css",
		"/../nonexistent.css",
		"/%2e%2e/nonexistent.css",
		"%0Anonexistent.css",
		"%3Bnonexistent.css",
		"%23nonexistent.css",
		"%3Fname = valnonexistent.css",
		"&name=valnonexistent.css",
	}

	PrintVerbose("Testing for Web Cache Deception\n", NoColor, 1)

	// test each appending one after another
	for _, appendStr := range appendings {
		err := webCacheDeceptionTemplate(&repResult, appendStr)
		if err != nil {
			repResult.HasError = true
			repResult.ErrorMessages = append(repResult.ErrorMessages, err.Error())
		}
	}

	return repResult
}

func webCacheDeceptionTemplate(repResult *reportResult, appendStr string) error {
	var req *http.Request
	var resp *http.Response
	var err error
	var msg string
	var body []byte
	var repRequest reportRequest

	rUrl := Config.Website.Url.String()
	req, err = http.NewRequest("GET", rUrl+appendStr, nil)
	if err != nil {
		msg = fmt.Sprintf("webCacheDeceptionTemplate: %s: http.NewRequest: %s\n", appendStr, err.Error())
		Print(msg, Red)
		return errors.New(msg)
	}

	// Do request
	newClient := http.Client{
		CheckRedirect: http.DefaultClient.CheckRedirect,
		Timeout:       http.DefaultClient.Timeout,
	}

	resp, err = newClient.Do(req)
	if err != nil {
		msg = fmt.Sprintf("webCacheDeceptionTemplate: %s: newClient.Do: %s\n", appendStr, err.Error())
		PrintVerbose(msg, Yellow, 1)
		return errors.New(msg)
	} else {
		defer resp.Body.Close()

		body, err = io.ReadAll(resp.Body)
		if err != nil {
			msg = fmt.Sprintf("webCacheDeceptionTemplate: %s: io.ReadAll: %s\n", appendStr, err.Error())
			Print(msg, Red)
			return errors.New(msg)
		}

		if resp.StatusCode != Config.Website.StatusCode {
			msg = fmt.Sprintf("Unexpected Status Code %d for webCacheDeceptionTemplate: %s\n", resp.StatusCode, appendStr)
			Print(msg, Yellow)
		}
	}

	// Add the request as curl command to the report
	command, err := http2curl.GetCurlCommand(req)
	if err != nil {
		PrintVerbose("Error: http2curl: "+err.Error()+"\n", Yellow, 1)
	}
	repRequest.CurlCommand = command.String()

	indicValue := strings.TrimSpace(strings.ToLower(resp.Header.Get(Config.Website.Cache.Indicator)))
	// check if there's a cache hit and if the body didn't change (otherwise it could be a cached error page, for example)
	if checkCacheHit(indicValue) && string(body) == Config.Website.Body {
		repResult.Vulnerable = true
		repRequest.Reason = "The response got cached due to Web Cache Deception"
		msg = fmt.Sprintf("%s was successfully decepted! appended: %s\n", rUrl, appendStr)
		Print(msg, Green)
		msg = "Curl: " + repRequest.CurlCommand + "\n\n"
		Print(msg, Green)
	} else {
		PrintVerbose("Curl command: "+repRequest.CurlCommand+"\n", NoColor, 2)
	}

	repRequest.URL = req.URL.String()
	// Dump the request without the body
	var dumpReqBytes []byte
	dumpReqBytes, _ = httputil.DumpRequest(req, false)
	repRequest.Request = string(dumpReqBytes)
	// Dump the response
	responseBytes, _ := httputil.DumpResponse(resp, true)
	repRequest.Response = string(responseBytes)

	repResult.Requests = append(repResult.Requests, repRequest)

	return nil
}
