package pkg

import (
	"flag"
	"fmt"
	"os"
	"strings"
	"text/tabwriter"
)

var version string

var generalOptions = []FlagStruct{}
var requestOptions []FlagStruct
var wordlistOptions []FlagStruct

type FlagStruct struct {
	LongFlag    string
	ShortFlag   string
	Description string
}

func init() {

}

func ParseFlags(vers string) {
	/* Getting Command-line flags */
	version = vers

	// General Options
	techniqueNames := "cookies,forwarded,dos,headers,parameters,fatget,cloaking"

	var recExcludeStr string

	generalOptions = appendInt(generalOptions, &Config.Verbosity,
		"verbosity", "v", 1, "Set verbosity. 0 = quiet, 1 = normal, 2 = verbose")
	generalOptions = appendInt(generalOptions, &Config.Threads,
		"threads", "t", 20, "Threads to use. Default value is 20")
	generalOptions = appendInt(generalOptions, &Config.TimeOut,
		"timeout", "to", 15, "Seconds until timeout. Default value is 15")
	generalOptions = appendInt(generalOptions, &Config.Recursivity,
		"recursivity", "r", 0, "Put (via href or src specified) urls at the end of the queue if the domain is the same. Specify how deep the recursivity shall go. Default value is 0 (no recursivity)")
	generalOptions = appendString(generalOptions, &Config.RecInclude,
		"recinclude", "rin", "", "Choose which links should be included. Seperate with a space. E.g: -rin '.js .css'")
	generalOptions = appendString(generalOptions, &recExcludeStr,
		"recexclude", "rex", "", "Use -cp (-completedpath) or -gc (-generatecompleted) to generate a list of already completed URLs. Use -rex path/to/file so the already completed URLs won't be tested again recursively.")
	generalOptions = appendString(generalOptions, &Config.DoTest,
		"dotest", "dt", "", "Choose which tests to run. Use the , seperator to specify multiple ones. Example: -doTest '"+techniqueNames+"'")
	generalOptions = appendString(generalOptions, &Config.DontTest,
		"donttest", "dnt", "", "Choose which tests to not run. Use the , seperator to specify multiple ones. Example: -dontTest '"+techniqueNames+"'")
	generalOptions = appendString(generalOptions, &Config.ProxyCertPath,
		"proxycertpath", "ppath", "", "Path to the cert of the proxy you want to use. The cert has to have the PEM Format. Burp e.g. is in the DER Format. Use the following command to convert it: openssl x509 -inform DER -outform PEM -text -in cacert.der -out certificate.pem")
	generalOptions = appendString(generalOptions, &Config.ProxyURL,
		"proxyurl", "purl", "http://127.0.0.1:8080", "Url for the proxy. Default value is http://127.0.0.1:8080")
	generalOptions = appendBoolean(generalOptions, &Config.Force,
		"force", "f", false, "Perform the tests no matter if there is a cache or even the cachebuster works or not")
	generalOptions = appendBoolean(generalOptions, &Config.GenerateReport,
		"generatereport", "gr", false, "Do you want a report to be generated?")
	generalOptions = appendString(generalOptions, &Config.ReportPath,
		"reportpath", "rp", "", "Set the name and/or path of the report file if one is needed. Use (C:/)/p/a/t/h/ to only specify the path or (C:/)/p/a/t/h/filename to specify the path and name")
	generalOptions = appendBoolean(generalOptions, &Config.EscapeJSON,
		"escapejson", "ej", false, "Do you want HTML special chars to be encoded in the report?")
	generalOptions = appendBoolean(generalOptions, &Config.GenerateCompleted,
		"generatecompleted", "gc", false, "Do you want a list with completed URLs to be generated?")
	generalOptions = appendString(generalOptions, &Config.CompletedPath,
		"completedpath", "cp", "", "Set the name and/or path of the completed URLs file if one is needed. Use (C:/)/p/a/t/h/ to only specify the path or (C:/)/p/a/t/h/filename to specify the path and name")

	// Request Options
	var urlStr string
	var setCookiesStr string
	var setHeadersStr string
	var setParametersStr string
	var setBodyStr string

	requestOptions = appendString(requestOptions, &urlStr,
		"url", "u", "", "Url to scan. Has to start with http:// or https://. Otherwise use file: to specify a file with (multiple) urls. E.g. -u https://www.example.com or -u file:templates/url_list")
	requestOptions = appendBoolean(requestOptions, &Config.DeclineCookies,
		"declineCookies", "dc", false, "Do you don't want to use cookies, which are received in the response of the first request?")
	requestOptions = appendString(requestOptions, &Config.CacheBuster,
		"cachebuster", "cb", "cachebuster", "Specify the cachebuster to use. The default value is cachebuster")
	requestOptions = appendString(requestOptions, &setCookiesStr,
		"setcookies", "sc", "", "Set a Cookie. Otherwise use file: to specify a file with urls. E.g. -sc uid=123 or -sc file:templates/cookie_list")
	requestOptions = appendString(requestOptions, &setHeadersStr,
		"setheaders", "sh", "", "Set a Header. Otherwise use file: to specify a file with urls. E.g. -sh 'User-Agent: Safari/1.1' or -sh file:templates/header_list")
	requestOptions = appendString(requestOptions, &setParametersStr,
		"setparameters", "sp", "", "Set a Query Parameter. Otherwise use file: to specify a file with urls. E.g. -sp user=admin or -sp file:templates/parameter_list")
	requestOptions = appendString(requestOptions, &setBodyStr,
		"setbody", "sb", "", "Set the requests' body. Otherwise use file: to specify a file with urls. E.g. -sb 'admin=true' or -sh file:templates/body_file")
	requestOptions = appendBoolean(requestOptions, &Config.DoPost,
		"post", "post", false, "Do a POST request instead of a GET request")
	requestOptions = appendString(requestOptions, &Config.ContentType,
		"contenttype", "ct", "application/x-www-form-urlencoded", "Set the contenttype for a POST Request. Default is application/x-www-form-urlencoded. If you don't want a content-type to be used at all use -ct ''")
	requestOptions = appendInt(requestOptions, &Config.StatusCode,
		"statuscode", "status", 0, "Expected status code of the responses. If not specified it takes the status code of the first response")
	requestOptions = appendString(requestOptions, &Config.QuerySeperator,
		"parameterseperator", "ps", "&", "Specify the seperator for parameters. The default value is &")

	// Wordlist Options
	wordlistOptions = appendString(wordlistOptions, &Config.HeaderWordlist,
		"headerwordlist", "hw", "wordlists/top-headers", "Wordlist for headers to test. Default path is 'wordlists/top-headers'")
	wordlistOptions = appendString(wordlistOptions, &Config.QueryWordlist,
		"querywordlist", "qw", "wordlists/top-parameters", "Wordlist for query parameters to test. Default path is 'wordlists/top-parameters'")

	flag.CommandLine.Usage = help

	// flags need to be parsed, before they are used
	flag.Parse()

	/* Checking values of Flags */
	if len(flag.Args()) > 0 {
		msg := fmt.Sprintf("%s: Args are not supported! Use flags. Use -h or --help to get a list of all supported flags\n", flag.Args())
		PrintFatal(msg)
	}
	if urlStr == "" {
		msg := "No url specified. Use -url or -u. Use -h or --help to get a list of all supported flags\n"
		PrintFatal(msg)
	}

	// Read RecExcludeURL(s)
	if recExcludeStr != "" {
		Config.RecExclude = ReadLocalFile(recExcludeStr)
	}

	// Read URL(s)
	Config.Urls = readFile(urlStr, Config.Urls)

	// Read Cookie(s)
	Config.Cookies = readFile(setCookiesStr, Config.Cookies)

	// Read Header(s)
	Config.Headers = readFile(setHeadersStr, Config.Headers)

	// Read Parameter(s)
	Config.Parameters = readFile(setParametersStr, Config.Parameters)

	/* Read Body */
	if strings.HasPrefix(setBodyStr, "path:") {
		bodySlice := ReadLocalFile(setBodyStr)
		for _, l := range bodySlice {
			l = strings.TrimSuffix(l, "\r")
			l = strings.TrimSpace(l)
			if strings.HasPrefix(l, "//") || l == "" {
				continue
			}
			Config.Body += l
		}
	} else {
		Config.Body = setBodyStr
	}
}

func readFile(str string, field []string) []string {
	if strings.HasPrefix(str, "path:") {
		return ReadLocalFile(str)
	} else {
		return append(field, str)
	}
}

func help() {
	w := new(tabwriter.Writer)
	w.Init(os.Stdout, 8, 8, 0, '\t', 0)

	fmt.Println("https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner")
	fmt.Printf("version %s\n\n", version)
	fmt.Print("Usage: Web-Cache-Vulnerability-Scanner(.exe) [options]\n\n")

	fmt.Println("General Options:")
	fmt.Fprintf(w, "%s\t%s\t%s\n", "--help", "-h", "Show this help and quit")
	for _, ts := range generalOptions {
		fmt.Fprintf(w, "--%s\t-%s\t%s\n", ts.LongFlag, ts.ShortFlag, ts.Description)
	}
	w.Flush()

	fmt.Println("\nRequest Options:")
	for _, ts := range requestOptions {
		fmt.Fprintf(w, "--%s\t-%s\t%s\n", ts.LongFlag, ts.ShortFlag, ts.Description)
	}
	w.Flush()

	fmt.Println("\nWordlist Options:")
	for _, ts := range wordlistOptions {
		fmt.Fprintf(w, "--%s\t  -%s\t%s\n", ts.LongFlag, ts.ShortFlag, ts.Description)
	}
	w.Flush()

	os.Exit(0)
}

func appendString(options []FlagStruct, varString *string, longFlag string, shortFlag string, defaultValue string, description string) []FlagStruct {
	flag.StringVar(varString, longFlag, defaultValue, "")
	if shortFlag != longFlag {
		flag.StringVar(varString, shortFlag, defaultValue, "")
	}
	return append(options, FlagStruct{
		LongFlag:    longFlag,
		ShortFlag:   shortFlag,
		Description: description})
}

func appendInt(options []FlagStruct, varInt *int, longFlag string, shortFlag string, defaultValue int, description string) []FlagStruct {
	flag.IntVar(varInt, longFlag, defaultValue, "")
	if shortFlag != longFlag {
		flag.IntVar(varInt, shortFlag, defaultValue, "")
	}
	return append(options, FlagStruct{
		LongFlag:    longFlag,
		ShortFlag:   shortFlag,
		Description: description})
}

func appendBoolean(options []FlagStruct, varBoolean *bool, longFlag string, shortFlag string, defaultValue bool, description string) []FlagStruct {
	flag.BoolVar(varBoolean, longFlag, defaultValue, "")
	if shortFlag != longFlag {
		flag.BoolVar(varBoolean, shortFlag, defaultValue, "")
	}
	return append(options, FlagStruct{
		LongFlag:    longFlag,
		ShortFlag:   shortFlag,
		Description: description})
}
