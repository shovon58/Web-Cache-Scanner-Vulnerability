package pkg

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os"
	"strings"
)

type Result struct {
	Technique    string    `json:"technique"`
	HasError     bool      `json:"hasError"`
	ErrorMessage string    `json:"errorMessage"`
	Vulnerable   bool      `json:"isVulnerable"`
	Requests     []Request `json:"requests"`
}

type Request struct {
	Reason string      `json:"reason"`
	Method string      `json:"method"`
	URL    string      `json:"url"`
	Header http.Header `json:"header"`
	Body   string      `json:"body,omitempty"`
}

type Report struct {
	Name         string `json:"name"`
	Version      string `json:"version"`
	HasError     bool   `json:"hasError"`
	ErrorMessage string `json:"errorMessage"`
	Vulnerable   bool   `json:"isVulnerable"`
	Date         string `json:"date"`
	Duration     string `json:"duration"`

	Results []Result `json:"results,omitempty"`

	// Pointer for Structs which shall be omitted when empty
	Config *ConfigStruct `json:"config,omitempty"`
}

func init() {

}

func ExportReport(report Report, escapeJSON bool) error {

	reportPath := report.Config.ReportPath
	if reportPath == "" || strings.HasSuffix(reportPath, "/") || strings.HasSuffix(reportPath, "\\") {
		fileName := report.Date + "_WCVS_Report"
		reportPath += fileName
	}

	_, err := os.Stat(reportPath)

	var file *os.File
	defer file.Close()

	if !os.IsNotExist(err) {
		msg := fmt.Sprintf("The file %s will be overwritten, as it already exists\n", reportPath)
		PrintVerbose(msg, Yellow, 1)
		file, err = os.OpenFile(reportPath, os.O_WRONLY, 0666)
	} else {
		file, err = os.Create(reportPath)
	}
	if err != nil {
		msg := "Report: " + err.Error() + "\n"
		Print(msg, Red)
		return errors.New(msg)
	}

	indentPrefix := ""
	indentSuffix := "    "
	if escapeJSON {
		j, err := json.MarshalIndent(report, indentPrefix, indentSuffix)
		if err != nil {
			msg := fmt.Sprintf("Error occured during marshalling. Error %s\n", err.Error())
			Print(msg, Red)
			return errors.New(msg)
		}

		file.WriteString(string(j))
	} else {
		bf := bytes.NewBuffer([]byte{})
		jsonEncoder := json.NewEncoder(bf)
		jsonEncoder.SetEscapeHTML(false)
		jsonEncoder.SetIndent(indentPrefix, indentSuffix)
		jsonEncoder.Encode(report)

		file.WriteString(bf.String())
	}
	msg := fmt.Sprintf("Exported report %s\n", reportPath)
	Print(msg, NoColor)

	return nil
}
