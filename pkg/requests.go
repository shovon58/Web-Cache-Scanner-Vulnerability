package pkg

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httputil"
	"strings"
	"sync"
)

const respSplitHeader = "Web_Cache"
const respSplitValue = "Vulnerability_Scanner"

type requestParams struct {
	repResult        *reportResult
	headers          []string
	values           []string
	cookie           oldCookie
	identifier       string
	poison           string
	url              string
	url2             string
	cb               string
	success          string
	bodyString       string
	forcePost        bool
	duplicateHeaders bool
	m                *sync.Mutex
}

type oldCookie struct {
	position int
	oldValue string
}

func init() {
}

func getRespSplit() string {
	return "\\r\\n" + respSplitHeader + ": " + respSplitValue
}

func checkPoisoningIndicators(repResult *reportResult, request reportRequest, success string, body string, poison string, statusCode1 int, statusCode2 int, sameBodyLength bool, header http.Header, m *sync.Mutex) bool {
	testForResponseSplitting := false
	// forwardheader benutzen keinen mutex. deswegen macht das if hier keinen Sinn
	/*if m == nil {
		result.HasError = true
		msg := fmt.Sprintf("%s: checkPoisoningIndicators: mutex is nil", request.URL)
		Print(msg, Red)
		result.ErrorMessages = append(result.ErrorMessages, msg)
		return testForResponseSplitting
	}*/
	website := &Config.Website
	headerWithPoison := ""
	if header != nil && poison != "" {
		for x := range header {
			if x == respSplitHeader && header.Get(x) == respSplitValue {
				request.Reason = "HTTP Response Splitting"
			}
			if strings.Contains(header.Get(x), poison) {
				headerWithPoison = x
			}
		}
	}

	if request.Reason == "" {
		if poison != "" && strings.Contains(body, poison) {
			request.Reason = "Response Body contained " + poison
		} else if headerWithPoison != "" {
			request.Reason = fmt.Sprintf("%s header contains poison value %s", headerWithPoison, poison)
			testForResponseSplitting = true
		} else if statusCode1 >= 0 && statusCode1 != website.StatusCode && statusCode1 == statusCode2 {
			var statcode int
			count := 3
			if m != nil {
				m.Unlock()
			}
			for i := 0; i < count; i++ {
				statcode = getStatusCode()
				if statcode != -1 {
					break
				}
			}
			if m != nil {
				m.Lock()
			}
			if statcode == -1 {
				repResult.HasError = true
				msg := fmt.Sprintf("%s returned both times %d. But getStatusCode() timed out %d times in a row", request.URL, statusCode1, count)
				repResult.ErrorMessages = append(repResult.ErrorMessages, msg)
				return testForResponseSplitting
			} else if statcode != statusCode1 {
				request.Reason = fmt.Sprintf("Status Code %d differed from %d", statusCode1, website.StatusCode)
			} else {
				log.Println(request.URL + ": status code differs from default one, but getStatusCode returns also a different one")
				return testForResponseSplitting
			}
		} else if success != "" && sameBodyLength && len(body) > 0 && compareLengths(len(body), len(website.Body), 1000) {
			request.Reason = fmt.Sprintf("Length %d differed more than 1000 bytes from normal length %d", len(body), len(website.Body))
		} else {
			return testForResponseSplitting
		}
	}

	Print(success, Green)
	msg := "Reason: " + request.Reason + "\n\n"
	Print(msg, Green)
	repResult.Vulnerable = true
	repResult.Requests = append(repResult.Requests, request)
	return testForResponseSplitting
}

func compareLengths(len1 int, len2 int, limit int) bool {

	var diff int
	if len1 >= len2 {
		diff = len1 - len2
	} else {
		diff = len2 - len1
	}

	return diff > limit
}

/* Check if the second response makes sense or the continuation shall be stopped */
func stopContinuation(body []byte, statusCode int, headers http.Header) bool {
	if string(body) != Config.Website.Body {
		return false
	} else if statusCode != Config.Website.StatusCode {
		return false
	} else if len(headers) != len(Config.Website.Headers) {
		return false
	}

	for k, v := range headers {
		v2 := Config.Website.Headers.Values(k)

		// check if length of v and v2 is the same
		if len(v) != len(v2) {
			return false
		}
	}
	return true
}

func firstRequest(rp requestParams) ([]byte, int, reportRequest, http.Header, error) {
	var req *http.Request
	var resp *http.Response
	var err error
	var msg string
	var body []byte
	var repRequest reportRequest

	if rp.headers == nil {
		rp.headers = []string{""}
	}
	if rp.values == nil {
		rp.values = []string{""}
	}

	if rp.values[0] == "2ndrequest" {
		rp.identifier = fmt.Sprintf("2nd request of %s\n", rp.identifier)
	} else {
		rp.identifier = fmt.Sprintf("1st request of %s", rp.identifier)
	}

	if len(rp.headers) != len(rp.values) && rp.values[0] != "2ndrequest" {
		msg = fmt.Sprintf("%s: len(header) %s %d != len(value) %s %d", rp.identifier, rp.headers, len(rp.headers), rp.cookie.oldValue, len(rp.values))
		Print(msg, Red)
		return body, -1, repRequest, nil, errors.New(msg)
	}

	if Config.DoPost || rp.forcePost {
		if rp.bodyString == "" {
			rp.bodyString = Config.Body
		}
		req, err = http.NewRequest("POST", rp.url, bytes.NewBufferString(rp.bodyString))
	} else if rp.bodyString != "" {
		req, err = http.NewRequest("GET", rp.url, bytes.NewBufferString(rp.bodyString))
	} else {
		req, err = http.NewRequest("GET", rp.url, nil)
	}
	if err != nil {
		msg = rp.identifier + err.Error() + "\n"
		Print(msg, Red)
		return body, -1, repRequest, nil, errors.New(msg)
	}
	setRequest(req, Config.DoPost)

	for i := range rp.headers {
		if rp.headers[i] == "" {
			continue
		}
		if rp.values[0] == "2ndrequest" {
			msg = rp.identifier + "2nd request doesnt allow headers to be set\n"
			Print(msg, Red)
			break
		}
		if strings.EqualFold(rp.headers[i], "Host") && !rp.duplicateHeaders {
			newHost := req.URL.Host + rp.values[i]
			msg := fmt.Sprintf("Overwriting Host:%s with Host:%s\n", req.URL.Host, newHost)
			PrintVerbose(msg, NoColor, 1)
			req.Host = newHost
		} else if rp.headers[i] != "" {
			if h := req.Header.Get(rp.headers[i]); h != "" && !rp.duplicateHeaders {
				msg := fmt.Sprintf("Overwriting %s:%s with %s:%s\n", rp.headers[i], h, rp.headers[i], rp.values[i])
				Print(msg, NoColor)
				// Directly writing to map doesn't uppercase header(for HTTP1)
				req.Header[rp.headers[i]] = []string{rp.values[i]}
			} else if h != "" && rp.duplicateHeaders {
				// Directly writing to map doesn't uppercase the header(for HTTP1)
				req.Header[rp.headers[i]] = []string{h, rp.values[i]}
			} else {
				// Directly writing to map doesn't uppercase the header(for HTTP1)
				req.Header[rp.headers[i]] = []string{rp.values[i]}
			}
		}
	}

	resp, err = http.DefaultClient.Do(req)

	if err != nil {
		msg = fmt.Sprintf("%s %s\n", rp.identifier, err.Error())
		Print(msg, Yellow)
		return body, -1, repRequest, nil, errors.New(msg)
	} else {
		defer resp.Body.Close()

		body, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			msg = rp.identifier + err.Error() + "\n"
			Print(msg, Red)
			return body, -1, repRequest, nil, errors.New(msg)
		}

		if resp.StatusCode != Config.Website.StatusCode {
			msg = fmt.Sprintf("Unexpected Status Code %d for %s\n", resp.StatusCode, rp.identifier)
			Print(msg, Yellow)
		}
	}
	if stopContinuation(body, resp.StatusCode, resp.Header.Clone()) {
		msg := "stop"
		return body, -1, repRequest, nil, errors.New(msg)
	}

	requestBytes, _ := httputil.DumpRequestOut(req, true)
	repRequest.Request = string(requestBytes)

	responseBytes, _ := httputil.DumpResponse(resp, true)
	repRequest.Response = string(responseBytes)

	repRequest.URL = req.URL.String()

	return body, resp.StatusCode, repRequest, resp.Header.Clone(), nil
}

func secondRequest(urlCb string, identifier string) ([]byte, int, http.Header, error) {
	rp := requestParams{
		values:     []string{"2ndrequest"},
		identifier: identifier,
		url:        urlCb,
	}

	body, statusCode, _, header, err := firstRequest(rp)

	return body, statusCode, header, err
}

// TODO: ResponseSplitting Methode
/* return value:first bool is needed for responsesplitting, second bool is only needed for ScanParameters */
func issueRequest(rp requestParams) (bool, bool) {
	body1, statusCode1, request, _, err := firstRequest(rp)
	if err != nil {
		if err.Error() != "stop" {
			if rp.m != nil {
				rp.m.Lock()
			}
			rp.repResult.HasError = true
			rp.repResult.ErrorMessages = append(rp.repResult.ErrorMessages, err.Error())
			if rp.m != nil {
				rp.m.Unlock()
			}
		}
		// Set cookie back to oldValue
		if rp.cookie.oldValue != "" {
			Config.Website.Cookies[rp.cookie.position].Value = rp.cookie.oldValue
		}
		return false, false
	}

	// Set cookie back to oldValue
	if rp.cookie.oldValue != "" {
		Config.Website.Cookies[rp.cookie.position].Value = rp.cookie.oldValue
	}

	if rp.url2 == "" {
		rp.url2 = rp.url
	}

	body2, statusCode2, respHeader, err := secondRequest(rp.url2, rp.identifier)
	if err != nil {
		if err.Error() != "stop" {
			if rp.m != nil {
				rp.m.Lock()
			}
			rp.repResult.HasError = true
			rp.repResult.ErrorMessages = append(rp.repResult.ErrorMessages, err.Error())
			if rp.m != nil {
				rp.m.Unlock()
			}
		}
		return false, true
	}

	sameBodyLength := len(body1) == len(body2)

	rp.success += "URL: " + request.URL + "\n"
	if rp.m != nil {
		rp.m.Lock()
	}
	responseSplitting := checkPoisoningIndicators(rp.repResult, request, rp.success, string(body2), rp.poison, statusCode1, statusCode2, sameBodyLength, respHeader, rp.m)
	if rp.m != nil {
		rp.m.Unlock()
	}

	return responseSplitting, true
}
