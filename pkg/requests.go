package pkg

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httputil"
	"strings"
)

func init() {

}

func checkPoisoningIndicators(result Result, request Request, msg string, body string, poison string, statusCode1 int, statusCode2 int, header http.Header, timeOut bool) Result {
	//testForResponseSplitting := false
	website := &Config.Website
	headerWithPoison := ""
	if header != nil && poison != "" {
		for x := range header {
			if strings.Contains(header.Get(x), poison) {
				headerWithPoison = x
			}
		}
	}

	//extraInfo := ""

	if timeOut {
		request.Reason = "Request timed out... may be false positive!"
	} else if poison != "" && strings.Contains(body, poison) {
		request.Reason = "Response Body contained " + poison
	} else if headerWithPoison != "" {
		request.Reason = fmt.Sprintf("%s header contains poison value %s", headerWithPoison, poison)
		/*if (Config.SkipTest == "" && Config.OnlyTest == "") || strings.Contains(Config.OnlyTest, "splitting") || (Config.SkipTest != "" && !strings.Contains(Config.SkipTest, "splitting")) {
			testForResponseSplitting = true
			extraInfo = "Testing if HTTP Response Splitting is possible as the poison value gets reflected in a header\n"
		} else {
			extraInfo = "Skipping to test for HTTP Response Splitting, even though the poison value gets reflected in a header\n"
		}*/
	} else if statusCode1 >= 0 && statusCode1 != website.StatusCode && statusCode1 == statusCode2 {
		request.Reason = fmt.Sprintf("Status Code %d differed from %d", statusCode1, website.StatusCode)
	} else if msg != "" && len(body) > 0 && compareLengths(len(body), len(website.Body), 30) {
		request.Reason = fmt.Sprintf("Length %d differed more than 30 bytes from normal length %d", len(body), len(website.Body))
	} else {
		return result //, testForResponseSplitting
	}

	Print(msg, Green)
	msg = "Reason: " + request.Reason + "\n"
	Print(msg, Green)
	//PrintVerbose(extraInfo, NoColor, 1)
	result.Vulnerable = true
	result.Requests = append(result.Requests, request)
	return result //, testForResponseSplitting
}

func compareLengths(len1 int, len2 int, limit int) bool {

	var diff int
	if len1 >= len2 {
		diff = len1 - len2
	} else {
		diff = len2 - len1
	}

	return diff > limit
}

/* Check if the second response makes sense or the continuation shall be stopped */
func stopContinuation(timeOut bool, body []byte, statusCode int, headers http.Header) bool {
	if timeOut {
		return false
	} else if string(body) != Config.Website.Body {
		return false
	} else if statusCode != Config.Website.StatusCode {
		return false
	} else if len(headers) != len(Config.Website.Headers) {
		return false
	}

	for k, v := range headers {
		v2 := Config.Website.Headers.Values(k)

		// check if values v and v2 are the same
		if len(v) != len(v2) {
			return false
		}
		for i := range v {
			if v[i] != v2[i] {
				return false
			}
		}
	}
	return true
}

func firstRequest(urlCb string, identifier string, header []string, value []string, bodyString string, forcePost bool, duplicateHeaders bool) ([]byte, int, Request, http.Header, bool, error) {
	var req *http.Request
	var resp *http.Response
	var err error
	var msg string
	var body []byte
	var request Request
	timeOut := false

	if len(header) != len(value) {
		msg = "len(header) != len(value)"
		Print(msg, Red)
		return body, -1, request, nil, timeOut, errors.New(msg)
	}

	if value[0] == "2ndrequest" {
		identifier = fmt.Sprintf("2nd request of %s\n", identifier)
	} else {
		identifier = fmt.Sprintf("1st request of %s", identifier)
	}

	if Config.DoPost || forcePost {
		if bodyString == "" {
			bodyString = Config.Body
		}
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
	} else if bodyString != "" {
		req, err = http.NewRequest("GET", urlCb, bytes.NewBufferString(bodyString))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg = identifier + err.Error() + "\n"
		Print(msg, Red)
		return body, -1, request, nil, timeOut, errors.New(msg)
	}
	setRequest(req, Config.DoPost)

	for i := range header {
		if strings.EqualFold(header[i], "Host") && !duplicateHeaders {
			newHost := req.URL.Host + value[i]
			msg := fmt.Sprintf("Overwriting Host:%s with Host:%s\n", req.URL.Host, newHost)
			PrintVerbose(msg, NoColor, 1)
			req.Host = newHost
		} else if header[i] != "" {
			if h := req.Header.Get(header[i]); h != "" && !duplicateHeaders {
				msg := fmt.Sprintf("Overwriting %s:%s with %s:%s\n", header[i], h, header[i], value[i])
				Print(msg, NoColor)
				// Directly writing to map doesn't uppercase header(for HTTP1)
				req.Header[header[i]] = []string{value[i]}
			} else if h != "" && duplicateHeaders {
				// Directly writing to map doesn't uppercase the header(for HTTP1)
				req.Header[header[i]] = []string{h, value[i]}
			} else {
				// Directly writing to map doesn't uppercase the header(for HTTP1)
				req.Header[header[i]] = []string{value[i]}
			}
		}
	}

	resp, err = http.DefaultClient.Do(req)

	if err != nil {
		timeOut = strings.Contains(err.Error(), "Client.Timeout exceeded while awaiting headers")

		msg = fmt.Sprintf("%s %s\n", identifier, err.Error())
		Print(msg, Yellow)
		return body, -1, request, nil, timeOut, errors.New(msg)
	} else {
		defer resp.Body.Close()

		body, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			msg = identifier + err.Error() + "\n"
			Print(msg, Red)
			return body, -1, request, nil, timeOut, errors.New(msg)
		}

		if resp.StatusCode != Config.Website.StatusCode {
			msg = fmt.Sprintf("Unexpected Status Code %d for %s\n", resp.StatusCode, identifier)
			Print(msg, Yellow)
		}
	}
	if stopContinuation(timeOut, body, resp.StatusCode, resp.Header.Clone()) {
		msg := "stop"
		return body, -1, request, nil, timeOut, errors.New(msg)
	}

	requestBytes, _ := httputil.DumpRequestOut(req, true)
	request.Request = string(requestBytes)

	responseBytes, _ := httputil.DumpResponse(resp, true)
	request.Response = string(responseBytes)

	request.URL = req.URL.String()

	return body, resp.StatusCode, request, resp.Header.Clone(), timeOut, nil
}

func secondRequest(urlCb string, identifier string) ([]byte, int, http.Header, bool, error) {

	body, statusCode, _, header, timeOut, err := firstRequest(urlCb, identifier, []string{""}, []string{"2ndrequest"}, "", false, false)

	return body, statusCode, header, timeOut, err
}
