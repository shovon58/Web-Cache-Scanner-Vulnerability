package pkg

import (
	"bufio"
	"crypto/tls"
	"fmt"
	"net"
	"strings"
	"time"
)

func init() {

}

func GenerateHeaderString() string {
	headers := ""
	userAgent := useragent
	for _, h := range Config.Headers {
		h = strings.TrimSuffix(h, "\r")
		h = strings.TrimSpace(h)
		if h == "" {
			continue
		} else if !strings.Contains(h, ":") {
			msg := "Specified header" + h + "doesn't contain a : and will be skipped"
			Print(msg, NoColor)
			continue
		} else {
			headers += h + "\r\n"

			hSplitted := strings.SplitN(h, ":", 2)
			hSplitted[0] = strings.TrimSpace(hSplitted[0])
			hSplitted[1] = strings.TrimSpace(hSplitted[1])

			if strings.EqualFold(hSplitted[0], "User-Agent") {
				userAgent = hSplitted[1]
			}
		}
	}
	// if its the same, the useragent wasnt added yet
	if userAgent == useragent {
		headers += "User-Agent: " + useragent + "\r\n"
	}

	return headers
}

/* Run clte before tecl. Dont test for tecl if clte already works! */
func clte(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Transfer-Encoding: chunked\r\n"+ // Transfer-Encoding: chunked
		"Content-Length: 7\r\n"+ //			 Content-Length: 7
		"\r\n"+ //
		"1\r\n"+ //							 1
		"Z\r\n"+ //							 Z
		"Q"+ //								 Q
		"", Config.Website.Url.Path, Config.Website.Url.Host, headers)

	return payload
}

func tecl(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Transfer-Encoding: chunked\r\n"+ // Transfer-Encoding: chunked
		"Content-Length: 7\r\n"+ //			 Content-Length: 7
		"\r\n"+ //
		"0\r\n"+ //							 0
		"\r\n"+ //
		"X"+ //								 X
		"", Config.Website.Url.Path, Config.Website.Url.Host, headers)

	return payload
}

func clcl(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Content-Length: 10\r\n"+ // 		 Content-Length: 10
		"Content-Length: 11\r\n"+ //		 Content-Length: 11
		"\r\n"+ //
		"M\r\n"+ //							 M
		"1\r\n"+ //							 1
		"0\r\n"+ //							 0
		"X"+ //								 X
		"", Config.Website.Url.Path, Config.Website.Url.Host, headers)

	return payload
}

func clcl2(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Content-Length: 6\r\n"+ //			 Content-Length: 11
		"Content-Length: 4\r\n"+ //			 Content-Length: 10
		"\r\n"+ //
		"M\r\n"+ //							 M
		"1\r\n"+ //							 1
		"0\r\n"+ //							 0
		"X"+ //								 X
		"", Config.Website.Url.Path, Config.Website.Url.Host, headers)

	return payload
}

func httpRequestSmuggling(req string, result Result, tlsConfig *tls.Config) Result {
	https := false
	address := Config.Website.Domain
	address = strings.TrimSuffix(address, "/")
	if strings.HasPrefix(address, "https://") {
		https = true
		address = strings.TrimPrefix(address, "https://")
		if !strings.Contains(address, ":") {
			address += ":443"
		}
	} else if strings.HasPrefix(address, "http://") {
		address = strings.TrimPrefix(address, "http://")
		if !strings.Contains(address, ":") {
			address += ":80"
		}
	} else {
		msg := "Request Smuggling: " + address + " doesn't has http:// or https:// as prefix\n"
		Print(msg, Yellow)
		return result
	}

	dialer := net.Dialer{Timeout: time.Duration(Config.TimeOut) * time.Second}

	timeOutCount := 0
	for i := 0; i < 3; i++ {
		var err error
		var connS *tls.Conn
		var conn net.Conn
		var resp string
		var msg string

		if https {
			if tlsConfig == nil {
				tlsConfig = new(tls.Config)
				//tlsConfig.InsecureSkipVerify = true
			}
			connS, err = tls.Dial("tcp", address, tlsConfig)
		} else {
			conn, err = dialer.Dial("tcp", address)
		}
		if err != nil {
			PrintFatal("Request Smuggling:" + err.Error() + "\n")
		}

		if https {
			defer connS.Close()

			fmt.Fprint(connS, req)
			connS.SetReadDeadline(time.Now().Add(time.Duration(Config.TimeOut) * time.Second))
			resp, err = bufio.NewReader(connS).ReadString('\n')

		} else {
			defer conn.Close()

			fmt.Fprint(conn, req)
			conn.SetReadDeadline(time.Now().Add(time.Duration(Config.TimeOut) * time.Second))
			resp, err = bufio.NewReader(conn).ReadString('\n')

		}

		if err != nil {
			msg = "Request Smuggling: " + err.Error() + "\n"
			Print(msg, Yellow)

			// Time out error is same for TLS and Conn. Both use net.Error.Timeout
			nerr, _ := err.(net.Error)
			if nerr != nil && nerr.Timeout() {
				timeOutCount++
				msg = fmt.Sprintf("(%d/3) timeouts to confirm Request Smuggling\n", i+1)
				Print(msg, Yellow)
				//TODO: Wenn timeout, dann noch ein normales request senden, welches nicht auch timeouten darf?
			} else {
				msg = "Aborting test because of: " + err.Error() + "\n"
				Print(msg, Yellow)
				result.HasError = true
				result.ErrorMessages = append(result.ErrorMessages, msg)
				return result
			}
		} else {
			// When there isn't a timout this means that the Request Smuggling technique wasn't successful!
			// TODO: Print entfernen!
			if strings.Contains(resp, "500") {
				reason := "Server returned 500 Internal Server Error. It *may* be vulnerable to this Request Smuggling technique."
				result = fillRequest(result, reason, req, Config.Website.Url.String())
				msg = "Response:" + resp + reason + "\n"
				Print(msg, Green)
			} else {
				msg = "Response:" + resp + "Request didn't time out and therefore *likely* isn't vulnerable to this Request Smuggling technique.\n"
				Print(msg, Yellow)
			}
			return result
		}
	}

	if timeOutCount == 3 {
		msg := "The request timed out 3 times in a row. It is most likely vulnerable to this Request Smuggling technique."
		result = fillRequest(result, msg, req, Config.Website.Url.String())
		Print(msg+"\n", Green)
	}

	return result
}

func fillRequest(result Result, reason string, req string, reqURL string) Result {
	result.Vulnerable = true
	var request Request
	request.Reason = reason
	request.Request = req
	request.URL = reqURL
	result.Requests = append(result.Requests, request)
	return result
}
