package pkg

import (
	"bufio"
	"fmt"
	"net"
	"strings"
	"time"
)

func init() {

}

func generateHeaderString() string {
	headers := ""
	userAgent := useragent
	for _, h := range Config.Headers {
		h = strings.TrimSuffix(h, "\r")
		h = strings.TrimSpace(h)
		if h == "" {
			continue
		} else if !strings.Contains(h, ":") {
			msg := "Specified header" + h + "doesn't contain a : and will be skipped"
			Print(msg, NoColor)
			continue
		} else {
			headers += h + "\r\n"

			hSplitted := strings.SplitN(h, ":", 2)
			hSplitted[0] = strings.TrimSpace(hSplitted[0])
			hSplitted[1] = strings.TrimSpace(hSplitted[1])

			if strings.EqualFold(hSplitted[0], "User-Agent") {
				userAgent = hSplitted[1]
			}
		}
	}
	// if its the same, the useragent wasnt added yet
	if userAgent == useragent {
		headers += "User-Agent: " + useragent + "\r\n"
	}

	return headers
}

/* Run clte before TECL. Dont test for TECL if clte already works! */
func clte(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Transfer-Encoding: chunked\r\n"+ // Transfer-Encoding: chunked
		"Content-Length: 4\r\n"+ //			 Content-Length: 4
		"\r\n"+ //
		"1\r\n"+ //							 1
		"Z\r\n"+ //							 Z
		"Q\r\n"+ //							 Q
		"", Config.Website.Url.Path, Config.Website.BaseUrlStr, headers)

	return payload
}

func tecl(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Transfer-Encoding: chunked\r\n"+ // Transfer-Encoding: chunked
		"Content-Length: 6\r\n"+ //			 Content-Length: 6
		"\r\n"+ //
		"0\r\n"+ //							 0
		"\r\n"+ //
		"X\r\n"+ //							 X
		"", Config.Website.Url.Path, Config.Website.BaseUrlStr, headers)

	return payload
}

func clcl(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Content-Length: 4\r\n"+ // 		 Content-Length: 4
		"Content-Length: 6\r\n"+ //			 Content-Length: 6
		"\r\n"+ //
		"M\r\n"+ //							 M
		"1\r\n"+ //							 1
		"0\r\n"+ //							 0
		"X\r\n"+ //							 X
		"", Config.Website.Url.Path, Config.Website.BaseUrlStr, headers)

	return payload
}

func clcl2(headers string) string {
	payload := fmt.Sprintf(""+
		"POST %s HTTP/1.1\r\n"+ //			 POST /about HTTP/1.1
		"Host: %s\r\n"+ //					 Host: example.com
		"%s"+ //							 *Additional Headers generated*
		"Content-Length: 6\r\n"+ //			 Content-Length: 6
		"Content-Length: 4\r\n"+ //			 Content-Length: 4
		"\r\n"+ //
		"M\r\n"+ //							 M
		"1\r\n"+ //							 1
		"0\r\n"+ //							 0
		"X\r\n"+ //							 X
		"", Config.Website.Url.Path, Config.Website.BaseUrlStr, headers)

	return payload
}

func httpRequestSmuggling(req string, result Result) Result {
	address := strings.TrimPrefix(Config.Website.Domain, "http")
	address = strings.TrimPrefix(address, "s")
	address = strings.TrimPrefix(address, "://")
	address = strings.TrimSuffix(address, "/")

	dialer := net.Dialer{Timeout: time.Duration(Config.TimeOut) * time.Second}

	for i := 0; i < 3; i++ {
		conn, err := dialer.Dial("tcp", address+":80")
		if err != nil {
			PrintFatal(err.Error())
		}
		defer conn.Close()

		fmt.Fprint(conn, req)

		//Unterer Teil... Wenn Timeout zÃ¤hler hoch. Bei 3 mal timeout hat es geklappt. Zwischendurch vllt ein normales request, was nicht timeouten darf

		resp, err := bufio.NewReader(conn).ReadString('\n')
		if err != nil {
			msg := "Smuggling: " + err.Error() + "\n"
			Print(msg, Yellow)
			result.HasError = true
			result.ErrorMessages = append(result.ErrorMessages, msg)
			return result
		}
		Print(resp, NoColor)
	}

	return result
}
