package pkg

import (
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"os"
	"runtime"
	"strconv"
	"strings"
)

var NoColor = ""
var Reset = "\033[0m"
var Red = "\033[31m"
var Green = "\033[32m"
var Yellow = "\033[33m"
var Blue = "\033[34m"
var Purple = "\033[35m"
var Cyan = "\033[36m"
var Gray = "\033[37m"
var White = "\033[97m"

func init() {
	if runtime.GOOS == "windows" {
		Reset = ""
		Red = ""
		Green = ""
		Yellow = ""
		Blue = ""
		Purple = ""
		Cyan = ""
		Gray = ""
		White = ""
	}
}

func removeColors(msg string) string {
	msg = strings.ReplaceAll(msg, Reset, "")
	msg = strings.ReplaceAll(msg, Red, "")
	msg = strings.ReplaceAll(msg, Green, "")
	msg = strings.ReplaceAll(msg, Yellow, "")
	msg = strings.ReplaceAll(msg, Blue, "")
	msg = strings.ReplaceAll(msg, Purple, "")
	msg = strings.ReplaceAll(msg, Cyan, "")
	msg = strings.ReplaceAll(msg, Gray, "")
	msg = strings.ReplaceAll(msg, White, "")
	msg = strings.Trim(msg, "\n")
	return msg
}

func PrintVerbose(msg string, color string, threshold int) {
	if Config.Verbosity >= threshold {
		if color != NoColor {
			msg = color + msg + Reset
		}
		fmt.Print(msg)
	}
	log.Print(removeColors(msg))
}

func Print(msg string, color string) {
	PrintVerbose(msg, color, 0)
}

func PrintFatal(msg string) {
	Print(msg, Red)
	os.Exit(1)
}

func ReadLocalFile(path string) []string {
	path = strings.TrimPrefix(path, "file:")

	if strings.HasPrefix(strings.ToLower(path), "file:") {
		PrintFatal("Please make sure that path: is lowercase")
	}

	w, err := ioutil.ReadFile(path)
	if err != nil {
		PrintFatal(path + ": " + err.Error() + "\n")
	}

	return strings.Split(string(w), "\n")
}

func setRequest(req *http.Request, doPost bool) {
	setRequestHeaders(req)
	//TODO config nötig oder nur config.Website.Cookies?
	setRequestCookies(req)

	// Content-Type nur hinzufügen, wenn nicht schon vorher geschehen
	if doPost {
		if req.Header.Get("Content-Type") == "" && Config.ContentType != "" {
			req.Header.Add("Content-Type", Config.ContentType)
		}
	}
}

/* TODO wie bei requestCookies nur die erste occurance eines headers aufnehmen */
func setRequestHeaders(req *http.Request) {
	req.Header.Set("User-Agent", useragent)
	for _, h := range Config.Headers {
		h = strings.TrimSuffix(h, "\r")
		h = strings.TrimSpace(h)
		if h == "" {
			continue
		} else if !strings.Contains(h, ":") {
			msg := "Specified header" + h + "doesn't contain a : and will be skipped"
			Print(msg, NoColor)
			continue
		} else {
			hSplitted := strings.SplitN(h, ":", 2)

			req.Header.Set(strings.TrimSpace(hSplitted[0]), strings.TrimSpace(hSplitted[1]))
		}
	}
}

/* */
func setRequestCookies(req *http.Request) {
	for i, c := range Config.Website.Cookies {
		// only add first occurence of a cookie to the request
		// remove every other occurence
		_, err := req.Cookie(c.Name)
		if err == http.ErrNoCookie {
			req.AddCookie(c)
		} else if i < len(Config.Website.Cookies) {
			Config.Website.Cookies = append(Config.Website.Cookies[:i], Config.Website.Cookies[i+1:]...)
		}
	}
}

func addCachebuster(req *http.Request, cb string) {
	if cb == "" {
		return
	}

	cache := Config.Website.Cache
	if cache.CBisParameter {
		req.URL.Path, _ = addCachebusterParameter(req.URL.Path, cb)
	}
	if cache.CBisHeader {
		req.Header.Set(cache.CBName, cb)
	}
	if cache.CBisCookie {
		Config.Website.Cache.CBoldVal = Config.Website.Cookies[cache.CBint].Value
		Config.Website.Cookies[cache.CBint].Value = cb
	}
}

func addCachebusterParameter(strUrl string, cb string) (string, string) {
	if cb == "" {
		cb = randInt()
	}
	if !strings.Contains(strUrl, "?") {
		strUrl += "?" + Config.Website.Cache.CBName + "=" + cb
	} else {
		strUrl += Config.QuerySeperator + Config.Website.Cache.CBName + "=" + cb
	}

	return strUrl, cb
}

/* Create a random long integer */
func randInt() string {
	min := 100000000
	max := 999999999
	result := min + rand.Intn(max-min)
	return strconv.Itoa(result)
}

func waitLimiter(identifier string) {
	err := Config.Limiter.Wait(context.Background())
	if err != nil {
		msg := identifier + " rate Wait: " + err.Error()
		Print(msg, Red)
	}
}

// check if cache was hit
func checkCacheHit(value string) bool {
	ageIndi := Config.Website.Cache.AgeIndicator
	return (!ageIndi && strings.Contains(value, "hit")) || (ageIndi && value == "0")
}

// check if cache was missed
func checkCacheMiss(value string) bool {
	ageIndi := Config.Website.Cache.AgeIndicator
	return (!ageIndi && strings.Contains(value, "miss")) || (ageIndi && value != "0")
}
