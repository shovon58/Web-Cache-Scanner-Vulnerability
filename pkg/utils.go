package pkg

import (
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"strconv"
	"strings"
)

func init() {

}

func ReadLocalFile(path string) []string {
	path = strings.TrimPrefix(path, "path:")

	if strings.HasPrefix(strings.ToLower(path), "path:") {
		log.Fatalln("Please make sure that path: is lowercase")
	}

	w, err := ioutil.ReadFile(path)
	if err != nil {
		log.Fatalln(err)
	}

	return strings.Split(string(w), "\n")
}

func setRequest(req *http.Request, doPost bool, config Config) {
	setRequestHeaders(req, config.Headers)
	//TODO config nötig oder nur config.Website.Cookies?
	setRequestCookies(req, config)

	// Content-Type nur hinzufügen, wenn nicht schon vorher geschehen
	if doPost {
		if req.Header.Get("Content-Type") == "" && config.ContentType != "" {
			req.Header.Add("Content-Type", config.ContentType)
		}
	}
}

/* TODO wie bei requestCookies nur die erste occurance eines headers aufnehmen */
func setRequestHeaders(req *http.Request, headers []string) {
	for _, h := range headers {
		h = strings.TrimSuffix(h, "\r")
		h = strings.TrimSpace(h)
		if h == "" {
			continue
		} else if !strings.Contains(h, ":") {
			log.Println("Specified header", h, "doesn't contain a : and will be skipped")
			continue
		} else {
			hSplitted := strings.Split(h, ":")

			req.Header.Add(strings.TrimSpace(hSplitted[0]), strings.TrimSpace(hSplitted[1]))
		}
	}
}

/* */
func setRequestCookies(req *http.Request, config Config) {
	for i, c := range config.Website.Cookies {
		// only add first occurence of a cookie to the request
		// remove every other occurence
		_, err := req.Cookie(c.Name)
		if err == http.ErrNoCookie {
			req.AddCookie(c)
		} else if i != len(config.Website.Cookies) {
			config.Website.Cookies = append(config.Website.Cookies[:i], config.Website.Cookies[i+1:]...)
		}
	}
}

func addCacheBuster(strUrl string, cb string, cacheBuster string) (string, string) {
	if cb == "" {
		cb = randInt()
	}
	strUrl += cacheBuster + "=" + cb

	return strUrl, cb
}

/* Create a random long integer */
func randInt() string {
	min := 100000000
	max := 999999999
	result := min + rand.Intn(max-min)
	return strconv.Itoa(result)
}
