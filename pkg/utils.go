package pkg

import (
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"os"
	"runtime"
	"strconv"
	"strings"
)

var NoColor = ""
var Reset = "\033[0m"
var Red = "\033[31m"
var Green = "\033[32m"
var Yellow = "\033[33m"
var Blue = "\033[34m"
var Purple = "\033[35m"
var Cyan = "\033[36m"
var Gray = "\033[37m"
var White = "\033[97m"

var Verbosity int

func init() {
	if runtime.GOOS == "windows" {
		Reset = ""
		Red = ""
		Green = ""
		Yellow = ""
		Blue = ""
		Purple = ""
		Cyan = ""
		Gray = ""
		White = ""
	}
}

func SetVerbosity(verbosity int) {
	Verbosity = verbosity
}

func removeColors(msg string) string {
	msg = strings.ReplaceAll(msg, Reset, "")
	msg = strings.ReplaceAll(msg, Red, "")
	msg = strings.ReplaceAll(msg, Green, "")
	msg = strings.ReplaceAll(msg, Yellow, "")
	msg = strings.ReplaceAll(msg, Blue, "")
	msg = strings.ReplaceAll(msg, Purple, "")
	msg = strings.ReplaceAll(msg, Cyan, "")
	msg = strings.ReplaceAll(msg, Gray, "")
	msg = strings.ReplaceAll(msg, White, "")
	msg = strings.Trim(msg, "\n")
	return msg
}

func PrintVerbose(msg string, color string, threshold int) {
	if Verbosity >= threshold {
		if color != NoColor {
			msg = color + msg + Reset
		}
		fmt.Print(msg)
	}
	log.Print(removeColors(msg))
}

func Print(msg string, color string) {
	PrintVerbose(msg, color, 9)
}

func PrintFatal(msg string) {
	Print(msg, Red)
	os.Exit(1)
}

func ReadLocalFile(path string) []string {
	path = strings.TrimPrefix(path, "path:")

	if strings.HasPrefix(strings.ToLower(path), "path:") {
		PrintFatal("Please make sure that path: is lowercase")
	}

	w, err := ioutil.ReadFile(path)
	if err != nil {
		PrintFatal(err.Error() + "\n")
	}

	return strings.Split(string(w), "\n")
}

func setRequest(req *http.Request, doPost bool, config Config) {
	setRequestHeaders(req, config.Headers)
	//TODO config nötig oder nur config.Website.Cookies?
	setRequestCookies(req, config)

	// Content-Type nur hinzufügen, wenn nicht schon vorher geschehen
	if doPost {
		if req.Header.Get("Content-Type") == "" && config.ContentType != "" {
			req.Header.Add("Content-Type", config.ContentType)
		}
	}
}

/* TODO wie bei requestCookies nur die erste occurance eines headers aufnehmen */
func setRequestHeaders(req *http.Request, headers []string) {
	for _, h := range headers {
		h = strings.TrimSuffix(h, "\r")
		h = strings.TrimSpace(h)
		if h == "" {
			continue
		} else if !strings.Contains(h, ":") {
			msg := "Specified header" + h + "doesn't contain a : and will be skipped"
			Print(msg, NoColor)
			continue
		} else {
			hSplitted := strings.Split(h, ":")

			req.Header.Add(strings.TrimSpace(hSplitted[0]), strings.TrimSpace(hSplitted[1]))
		}
	}
}

/* */
func setRequestCookies(req *http.Request, config Config) {
	for i, c := range config.Website.Cookies {
		// only add first occurence of a cookie to the request
		// remove every other occurence
		_, err := req.Cookie(c.Name)
		if err == http.ErrNoCookie {
			req.AddCookie(c)
		} else if i != len(config.Website.Cookies) {
			config.Website.Cookies = append(config.Website.Cookies[:i], config.Website.Cookies[i+1:]...)
		}
	}
}

func addCacheBuster(strUrl string, cb string, cacheBuster string) (string, string) {
	if cb == "" {
		cb = randInt()
	}
	strUrl += cacheBuster + "=" + cb

	return strUrl, cb
}

/* Create a random long integer */
func randInt() string {
	min := 100000000
	max := 999999999
	result := min + rand.Intn(max-min)
	return strconv.Itoa(result)
}
