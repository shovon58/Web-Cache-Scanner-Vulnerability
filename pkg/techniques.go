package pkg

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"sync"
)

var impactfulQueries []string

func init() {
}

func checkPoisoningIndicators(result Result, request Request, msg string, body string, poison string, statusCode1 int, statusCode2 int, header http.Header, timeOut bool) Result {
	website := &Config.Website
	headerWithPoison := ""
	if header != nil && poison != "" {
		for x := range header {
			if strings.Contains(header.Get(x), poison) {
				headerWithPoison = x
			}
		}
	}

	if timeOut {
		request.Reason = "Request timed out... may be false positive!"
	} else if poison != "" && strings.Contains(body, poison) {
		request.Reason = "Response Body contained " + poison
	} else if headerWithPoison != "" {
		request.Reason = fmt.Sprintf("%s header contains poison value %s", headerWithPoison, poison)
	} else if statusCode1 >= 0 && statusCode1 != website.StatusCode && statusCode1 == statusCode2 {
		request.Reason = fmt.Sprintf("Status Code %d differed from %d", statusCode1, website.StatusCode)
	} else if msg != "" && len(body) > 0 && compareLengths(len(body), len(website.Body), 30) {
		request.Reason = fmt.Sprintf("Length %d differed more than 30 bytes from normal length %d", len(body), len(website.Body))
	} else {
		return result
	}

	Print(msg, Green)
	msg = "Reason: " + request.Reason + "\n"
	Print(msg, Green)
	result.Vulnerable = true
	result.Requests = append(result.Requests, request)
	return result
}

func compareLengths(len1 int, len2 int, limit int) bool {

	var diff int
	if len1 >= len2 {
		diff = len1 - len2
	} else {
		diff = len2 - len1
	}

	return diff > limit
}

func setReportRequest(req *http.Request, body string) Request {
	var request Request
	request.Method = req.Method
	request.URL = req.URL.String()
	request.Header = req.Header
	request.Body = body

	return request
}

/* Check if the second response makes sense or the continuation shall be stopped */
func stopContinuation(timeOut bool, body []byte, statusCode int, headers http.Header) bool {
	if timeOut {
		return false
	} else if string(body) != Config.Website.Body {
		return false
	} else if statusCode != Config.Website.StatusCode {
		return false
	} else if len(headers) != len(Config.Website.Headers) {
		return false
	}

	for k, v := range headers {
		v2 := Config.Website.Headers.Values(k)

		// check if values v and v2 are the same
		if len(v) != len(v2) {
			return false
		}
		for i := range v {
			if v[i] != v[2] {
				return false
			}
		}
	}
	return true
}

/* Scan cookies for poisoning */
func ScanCookies(client http.Client) Result {
	var result Result
	result.Technique = "Cookies"
	for i := 0; i < len(Config.Website.Cookies); i++ {
		poison := randInt()
		msg := fmt.Sprintf("Checking cookie %s\n", Config.Website.Cookies[i].Name)
		Print(msg, NoColor)

		urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)

		errorMessage := Config.Website.Cookies[i].String() + "=" + Config.Website.Cookies[i].Value

		var req *http.Request
		var err error

		bodyString := ""
		if Config.DoPost {
			bodyString = Config.Body
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := errorMessage + err.Error() + "\n"
			PrintFatal(msg)
		}

		msg = fmt.Sprintf("Overwriting %s=%s with %s=%s\n", Config.Website.Cookies[i].Name, Config.Website.Cookies[i].Value, Config.Website.Cookies[i].Name, poison)
		Print(msg, NoColor)
		oldValue := Config.Website.Cookies[i].Value
		Config.Website.Cookies[i].Value = poison

		setRequest(req, Config.DoPost)

		resp, err := client.Do(req)
		timeOut1 := false
		if err != nil && strings.Contains(err.Error(), "Client.Timeout exceeded while awaiting headers") {
			timeOut1 = true
			msg = fmt.Sprintf("%s\n", err.Error())
			Print(msg, Yellow)
			msg = fmt.Sprintf("cookie %s\n", Config.Website.Cookies[i].Name)
			Print(msg, Yellow)
		} else if err != nil {
			msg = errorMessage + err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		if resp.StatusCode != Config.Website.StatusCode {
			msg = fmt.Sprintf("Unexpected Status Code %d for %s=%s\n", resp.StatusCode, Config.Website.Cookies[i], Config.Website.Cookies[i].Value)
			Print(msg, Yellow)
		}

		_, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			msg = errorMessage + err.Error() + "\n"
			PrintFatal(msg)
		}

		Config.Website.Cookies[i].Value = oldValue

		request := setReportRequest(req, bodyString)

		//TODO: Check first request, if second is necessary?
		identifier := fmt.Sprintf("cookie %s", Config.Website.Cookies[i].Name)
		body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
		if err != nil && !timeOut2 {
			result.HasError = true
			result.ErrorMessage = err.Error()
			return result
		}

		msg = fmt.Sprintf("------- Cookie %s was successfully poisoned!!! cb: %s poison: %s -------\n%s\n", Config.Website.Cookies[i].Name, cb, poison, req.URL)
		result = checkPoisoningIndicators(result, request, msg, string(body), poison, resp.StatusCode, statusCode2, respHeader, timeOut1 && timeOut2)
	}
	return result
}

/* Scan X-Forwarded headers for poisoning */
func ScanXForwardedHeaders(client http.Client) Result {
	var result Result
	header := "X-Forwarded-Host and X-Forwarded-Scheme"
	result.Technique = header

	poison := randInt()

	urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)
	identifier := header

	_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{"X-Forwarded-Host", "X-Forwarded-Scheme"}, []string{poison, "nothttps"}, "", false)
	if err != nil && !timeOut1 {
		if err.Error() != "stop" {
			result.HasError = true
			result.ErrorMessage += err.Error()
		}
		return result
	}

	body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
	if err != nil && !timeOut2 {
		if err.Error() != "stop" {
			result.HasError = true
			result.ErrorMessage += err.Error()
		}
		return result
	}

	//strings.Contains(req.Host, poison) || entfernt, weil req nicht verfÃ¼gbar. Wird poison trotzdem gefunden?
	msg := fmt.Sprintf("------- %s was successfully poisoned!!! cb: %s poison: %s-------\n%s\n", header, cb, poison, request.URL)
	result = checkPoisoningIndicators(result, request, msg, string(body), poison, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)

	return result
}

/* Scan Host header for poisoning */
func ScanHostHeader(client http.Client) Result {
	var result Result
	header := "Host"
	result.Technique = header

	headervalues := []string{":123", ":@123", " 123"}

	for _, value := range headervalues {

		urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)

		identifier := header + value

		_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{header}, []string{value}, "", false)
		if err != nil && !timeOut1 {
			if err.Error() != "stop" {
				result.HasError = true
				result.ErrorMessage += err.Error()
			}
			continue
		}

		//TODO: Check first request, if second is necessary?
		body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
		if err != nil && !timeOut2 {
			if err.Error() != "stop" {
				result.HasError = true
				result.ErrorMessage += err.Error()
			}
			continue
		}

		msg := fmt.Sprintf("------- Host was successfully poisoned!!! cb: %s poison: %s-------\n%s\n", cb, value, request.URL)
		result = checkPoisoningIndicators(result, request, msg, string(body), value, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)
	}

	return result
}

/* Scan Forwarded header for poisoning */
func ScanForwardedHeader(client http.Client) Result {
	var result Result
	header := "Forwarded"
	result.Technique = header

	urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)
	poison := "host=" + randInt()
	identifier := header
	_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{header}, []string{poison}, "", false)
	if err != nil && !timeOut1 {
		if err.Error() != "stop" {
			result.HasError = true
			result.ErrorMessage += err.Error()
		}
		return result
	}

	//TODO: Check first request, if second is necessary?
	body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
	if err != nil && !timeOut2 {
		if err.Error() != "stop" {
			result.HasError = true
			result.ErrorMessage += err.Error()
		}
		return result
	}

	msg := fmt.Sprintf("------- %s was successfully poisoned!!! cb: %s poison: %s -------\n%s\n", header, cb, poison, request.URL)
	result = checkPoisoningIndicators(result, request, msg, string(body), poison, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)

	return result
}

/* Scan Forwarded header for poisoning */
func ScanXForwardedPortHeader(client http.Client) Result {
	var result Result
	header := "X-Forwarded-Port"
	result.Technique = header

	urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)
	poison := randInt()
	identifier := header
	_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{header}, []string{poison}, "", false)
	if err != nil && !timeOut1 {
		if err.Error() != "stop" {
			result.HasError = true
			result.ErrorMessage += err.Error()
		}
		return result
	}

	//TODO: Check first request, if second is necessary?
	body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
	if err != nil && !timeOut2 {
		if err.Error() != "stop" {
			result.HasError = true
			result.ErrorMessage += err.Error()
		}
		return result
	}

	msg := fmt.Sprintf("------- %s was successfully poisoned!!! cb: %s poison: %s -------\n%s\n", header, cb, poison, request.URL)
	result = checkPoisoningIndicators(result, request, msg, string(body), poison, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)

	return result
}

/* Scan headers for poisoning */
func ScanHeaders(client http.Client, headerList []string) Result {
	var result Result
	result.Technique = "Headers"

	//c := make(chan result) //<- needed?
	sem := make(chan int, Config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(headerList))

	for i, header := range headerList {
		header = strings.Trim(header, "\r")
		if header == "" {
			msg := fmt.Sprintf("Skipping empty header (%d/%d)\n", i+1, len(headerList))
			PrintVerbose(msg, NoColor, 1)

			wg.Done()
			continue
		}

		header = http.CanonicalHeaderKey(header)

		poison := randInt()

		go func(i int, header string, poison string) {
			defer wg.Done()
			sem <- 1

			msg := fmt.Sprintf("Testing now (%d/%d) %s\n", i+1, len(headerList), header)
			PrintVerbose(msg, NoColor, 2)

			urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)
			identifier := fmt.Sprintf("header %s", header)
			_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{header}, []string{poison}, "", false)
			if err != nil && !timeOut1 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			//TODO: Check first request, if second is necessary?
			body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
			if err != nil && !timeOut2 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			msg = fmt.Sprintf("------- Header %s was successfully poisoned!!! cb: %s poison: %s -------\n%s\n", header, cb, poison, request.URL)
			result = checkPoisoningIndicators(result, request, msg, string(body), poison, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)

			<-sem
		}(i, header, poison)

	}
	wg.Wait()

	return result
}

/* Scan query parameters for poisoning */
func ScanParameters(client http.Client, parameterList []string) Result {
	var result Result
	result.Technique = "Parameters"

	//c := make(chan result) //<- needed?
	sem := make(chan int, Config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(parameterList))

	impactfulQueries = nil

	for i, parameter := range parameterList {
		if parameter == "" {
			msg := fmt.Sprintf("Skipping empty query (%d/%d) %s\n", i+1, len(parameterList), parameter)
			PrintVerbose(msg, NoColor, 2)
			wg.Done()
			continue
		}

		poison := randInt()

		go func(i int, parameter string, poison string) {
			defer wg.Done()
			sem <- 1

			parameter = strings.Trim(parameter, "\r")

			msg := fmt.Sprintf("Testing now Parameter (%d/%d) %s\n", i+1, len(parameterList), parameter)
			PrintVerbose(msg, NoColor, 2)

			var urlCb, cb string
			if _, ok := Config.Website.Queries[parameter]; ok {
				// if the query to add is already present
				queryParameterMap := make(map[string]string)

				for key, val := range Config.Website.Queries {
					queryParameterMap[key] = val
				}

				msg := fmt.Sprintf("Overwriting %s=%s with %s=%s\n", parameter, queryParameterMap[parameter], parameter, poison)
				Print(msg, NoColor)
				queryParameterMap[parameter] = poison

				urlCb = Config.Website.BaseUrlStr + "?"
				for key, val := range queryParameterMap {
					if !strings.HasSuffix(urlCb, "?") {
						urlCb += "&"
					}
					urlCb += key + "=" + val
				}

				urlCb, cb = addCacheBuster(urlCb+Config.QuerySeperator, "", Config.CacheBuster)
			} else {
				// if query isn't already present, just add it and the cachebuster
				urlCb = Config.Website.Url.String()
				urlCb += parameter + "=" + poison + Config.QuerySeperator
				urlCb, cb = addCacheBuster(urlCb, "", Config.CacheBuster)
			}

			identifier := fmt.Sprintf("parameter %s", parameter)
			_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{""}, []string{poison}, "", false)
			if err != nil && !timeOut1 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			impactfulQueries = append(impactfulQueries, parameter)

			// get urlCb with the cachebuster but without the poisoned query
			urlCb, cb = addCacheBuster(Config.Website.Url.String(), cb, Config.CacheBuster)

			body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
			if err != nil && !timeOut2 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			msg = fmt.Sprintf("------- Query Parameter %s was successfully poisoned!!! cb: %s poison: %s -------\n%s\n", parameter, cb, poison, request.URL)
			result = checkPoisoningIndicators(result, request, msg, string(body), poison, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)

			<-sem
		}(i, parameter, poison)

	}
	wg.Wait()

	return result
}

/* Check for fat GET */
func ScanFatGET(client http.Client) Result {
	var result Result
	result.Technique = "Fat GET"

	if len(impactfulQueries) == 0 {
		errMsg := "No impactful query parameters were found beforehand. Run the query parameter scan (maybe with a different wordlist)."
		Print(errMsg+"\n", Yellow)
		result.HasError = true
		result.ErrorMessage = errMsg
		return result
	} else {
		msg := fmt.Sprintf("The following parameters were found to be impactful and will be tested for parameter cloaking: %s\n", impactfulQueries)
		Print(msg, NoColor)
	}

	//c := make(chan result) //<- needed?
	sem := make(chan int, Config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(impactfulQueries))

	msg := "\nTesting now simple Fat GET\n"
	Print(msg, NoColor)

	for i, s := range impactfulQueries {

		poison := randInt()

		// basic fat get technique
		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			msg = fmt.Sprintf("(%d/%d) %s\n", i+1, len(impactfulQueries), s)
			PrintVerbose(msg, NoColor, 2)

			urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)

			bodyString := s + "=" + poison
			identifier := fmt.Sprintf("simple Fat GET %s", s)
			_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{""}, []string{""}, bodyString, false)

			if err != nil && !timeOut1 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
			if err != nil && !timeOut2 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			msg = fmt.Sprintf("------- Query Parameter %s was successfully poisoned via simple Fat GET!!! cb: %s poison:%s -------\n%s\n", s, cb, poison, request.URL)
			result = checkPoisoningIndicators(result, request, msg, string(body), poison, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)

			<-sem
		}(i, s, poison)
	}
	wg.Wait()
	wg.Add(len(impactfulQueries))

	headers := []string{"X-HTTP-Method-Override", "X-HTTP-Method", "X-Method-Override"}

	for _, header := range headers {
		msg = fmt.Sprintf("\nTesting now %s Fat GET\n", header)
		Print(msg, NoColor)

		for i, s := range impactfulQueries {

			poison := randInt()

			// X-HTTP-Method-Override fat get technique
			go func(i int, s string, poison string) {
				defer wg.Done()
				sem <- 1

				msg = fmt.Sprintf("(%d/%d) %s\n", i+1, len(impactfulQueries), s)
				PrintVerbose(msg, NoColor, 2)

				urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)

				bodyString := s + "=" + poison

				//true so ContentType will be set
				//setRequest(req, true, Config)

				identifier := fmt.Sprintf("Fat GET %s %s", header, s)
				_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{header}, []string{"POST"}, bodyString, false)
				if err != nil && !timeOut1 {
					if err.Error() != "stop" {
						result.HasError = true
						result.ErrorMessage += err.Error()
					}
					<-sem
					return
				}

				body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
				if err != nil && !timeOut2 {
					if err.Error() != "stop" {
						result.HasError = true
						result.ErrorMessage += err.Error()
					}
					<-sem
					return
				}

				msg = fmt.Sprintf("------- Query Parameter %s was successfully poisoned via %s Fat GET!!! cb:%s poison:%s-------\n%s\n", s, header, cb, poison, request.URL)
				result = checkPoisoningIndicators(result, request, msg, string(body), poison, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)

				<-sem
			}(i, s, poison)
		}
		wg.Wait()
		wg.Add(len(impactfulQueries))
	}

	msg = "\nTesting now POST Fat GET\n"
	Print(msg, NoColor)

	for i, s := range impactfulQueries {

		poison := randInt()

		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			msg = fmt.Sprintf("(%d/%d) %s\n", i+1, len(impactfulQueries), s)
			PrintVerbose(msg, NoColor, 2)

			urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)

			var req *http.Request
			var err error

			bodyString := s + "=" + poison
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			// True so ContentType will be set
			//setRequest(req, true, Config)

			forcePost := true

			identifier := fmt.Sprintf("Post Fat GET %s", s)
			_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{""}, []string{""}, bodyString, forcePost)
			if err != nil && !timeOut1 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
			if err != nil && !timeOut2 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			msg = fmt.Sprintf("------- Query Parameter %s was successfully poisoned via POST Fat GET!!! cb:%s poison:%s -------\n%s\n", s, cb, poison, req.URL)
			result = checkPoisoningIndicators(result, request, msg, string(body), poison, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)

			<-sem
		}(i, s, poison)

	}
	wg.Wait()

	return result
}

/* Check for Parameter Cloaking */
func ScanParameterCloaking(client http.Client) Result {
	var result Result
	result.Technique = "Parameter Cloaking"

	if len(impactfulQueries) == 0 {
		errMsg := "No impactful query parameters were found beforehand. Run the query parameter scan (maybe with a different wordlist)."
		Print(errMsg+"\n", Yellow)
		result.HasError = true
		result.ErrorMessage = errMsg
		return result
	} else {
		msg := fmt.Sprintf("The following parameters were found to be impactful and will be tested for parameter cloaking:\n%s\n", impactfulQueries)
		Print(msg, NoColor)
	}

	utm_parameter := []string{"utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"}
	unkeyed_parameter := []string{}

	urlCb, _ := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)

	/***********Check if urlCb already contains utm parameter.
				Check if ? or querySeperator is needed
	****************/

	// The first request is made so a cache miss is forced and the following responses will only
	//have a cache hit, if they are unkeyed

	identifier := "first request %s"
	firstRequest(client, urlCb, identifier, []string{""}, []string{""}, "", false)

	sem := make(chan int, Config.Threads)
	var wg sync.WaitGroup

	if Config.Website.Cache.Indicator == "" {
		//Cant test if utm_parameter are unkeyed if X-Cache isn't set
		//So they will be all added as unkeyed_parameter
		msg := "hit/miss isn't verbose. Can't check which utm_parameter is unkeyed, so all will be used\n"
		Print(msg, Yellow)
		unkeyed_parameter = utm_parameter
	} else {
		//Test which utm_parameter are unkeyed
		//c := make(chan result) //<- needed?

		wg.Add(len(utm_parameter))
		for i, s := range utm_parameter {
			go func(i int, s string) {
				defer wg.Done()
				sem <- 1

				msg := fmt.Sprintf("Testing now for unkeyed utm parameters (%d/%d) %s\n", i+1, len(utm_parameter), s)
				PrintVerbose(msg, NoColor, 2)

				// add utm parameter after cachebuster. give utm parameter nonsense value
				urlPoisoned := urlCb + Config.QuerySeperator + s + "=foobar"
				identifier := fmt.Sprintf("unkeyed utm %s", s)
				//TODO: TimeOut behandeln!!!
				_, _, _, respHeader, _, err := firstRequest(client, urlPoisoned, identifier, []string{""}, []string{""}, "", false)
				if err == nil && respHeader != nil && strings.Contains(strings.ToLower(respHeader.Get(Config.Website.Cache.Indicator)), "hit") {
					unkeyed_parameter = append(unkeyed_parameter, s)
				} else if err != nil && err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
			}(i, s)
		}
		wg.Wait()
	}

	if len(unkeyed_parameter) == 0 {
		msg := "No unkeyed utm parameters could be found. Parameter Cloaking is not possible using utm parameters\n"
		Print(msg, Yellow)
	} else {
		msg := fmt.Sprintf("The following utm parameters were found to be unkeyed and will be tested for parameter cloaking:\n %s\n", unkeyed_parameter)
		Print(msg, NoColor)
	}

	cloak := ";"
	if Config.QuerySeperator == ";" {
		cloak = "&"
	}

	for iu, u := range unkeyed_parameter {

		//test one unkeyed parameter with all impactfulQueries one after another
		wg.Add(len(impactfulQueries))

		for is, s := range impactfulQueries {

			poison := randInt()

			go func(iu int, u string, is int, s string, poison string) {
				defer wg.Done()
				sem <- 1

				msg := fmt.Sprintf("Testing now Parameter Cloaking (%d/%d) %s%s%s\n", iu+is+1, len(impactfulQueries)*len(unkeyed_parameter), u, cloak, s)
				PrintVerbose(msg, NoColor, 2)

				urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)
				urlPoisoned := urlCb + Config.QuerySeperator + u + "=foobar" + cloak + s + "=" + poison

				identifier := fmt.Sprintf("parameter cloaking %s %s", u, s)
				_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlPoisoned, identifier, []string{""}, []string{poison}, "", false)
				if err != nil && !timeOut1 {
					if err.Error() != "stop" {
						result.HasError = true
						result.ErrorMessage += err.Error()
					}
					<-sem
					return
				}

				body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
				if err != nil && !timeOut2 {
					if err.Error() != "stop" {
						result.HasError = true
						result.ErrorMessage += err.Error()
					}
					<-sem
					return
				}

				msg = fmt.Sprintf("------- Query Parameter %s was successfully poisoned via Parameter Cloaking using %s!!! cb:%s poison:%s -------\n%s\n", s, u, cb, poison, request.URL)
				result = checkPoisoningIndicators(result, request, msg, string(body), poison, statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)

				<-sem
			}(iu, u, is, s, poison)
		}
		wg.Wait()
	}

	return result
}

/* Check for different DOS techniques */
func DOS(client http.Client) Result {
	var result Result
	result.Technique = "DOS"

	// TODO: Ist nur Header Value oder auch Header Name ausschlaggebend?
	result = hho(client, result)

	// TODO: Check for more META CHARACTERS?
	result = hmc(client, result)

	// TODO: Add more HEADERS/METHODS?
	result = hmo(client, result)

	// DOS via not implemented transferEncoding
	values := []string{"asdf"}
	result = headerDOSTemplate(client, result, values, "zTRANSFER-ENCODING", "Not supported Transfer-Encoding ")
	// DOS via incompatible/outdated browser agent
	// TODO: Add more USERAGENTS?
	values = []string{"Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US))"}
	result = headerDOSTemplate(client, result, values, "User-Agent", "incompatible browser ")
	// DOS via Max-Forwards (Webserver/Cache returns request)
	values = []string{"0", "1", "2"}
	result = headerDOSTemplate(client, result, values, "Max-Forwards", "")
	// DOS via waf blocking because of a blacklist word
	// TODO: change header to probably whitelisted header, More Blacklist words?
	values = []string{".burpcollaborator.net", "<script>alert(1)</script>"}
	result = headerDOSTemplate(client, result, values, "Any-Header", "blacklist ")
	// DOS via Range
	values = []string{"bytes=cow"}
	result = headerDOSTemplate(client, result, values, "Range", "")
	// DOS via X-Forwarded-Protocol
	values = []string{"http", "https", "ssl", "nonesense"}
	result = headerDOSTemplate(client, result, values, "X-Forwarded-Protocol", "")
	// DOS via X-Fordwarded-SSL
	values = []string{"on", "off", "nonsense"}
	result = headerDOSTemplate(client, result, values, "X-Forwarded-SSL", "")

	return result
}

/* HTTP Header Oversize */
func hho(client http.Client, result Result) Result {
	repetitions := []int{50, 100, 200} //4k, 8k, 16k

	msg := fmt.Sprintf("Testing now HHO with Size Limits of %dk bytes\n", repetitions)
	Print(msg, NoColor)

	for _, repetition := range repetitions {
		limit := repetition * 8 / 100
		//msg := fmt.Sprintf("Testing now HHO with Size Limit %dk bytes\n", limit)
		//Print(msg, NoColor)

		urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)

		headers := []string{}
		values := []string{}

		for i := 0; i < repetition; i++ {
			headername := fmt.Sprintf("X-Oversized-Header-%d", i+1)
			value := "Big-Value-000000000000000000000000000000000000000000000000000000000000000000000000000000"
			headers = append(headers, headername)
			values = append(values, value)
		}

		identifier := fmt.Sprintf("HHO with limit of %dk bytes", limit)
		_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, headers, values, "", false)
		if err != nil && !timeOut1 {
			if err.Error() != "stop" {
				result.HasError = true
				result.ErrorMessage += err.Error()
			}
			continue
		}

		//TODO: Check first request, if second is necessary?
		_, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
		if err != nil && !timeOut2 {
			if err.Error() != "stop" {
				result.HasError = true
				result.ErrorMessage += err.Error()
			}
			continue
		}

		msg = fmt.Sprintf("------- HHO DOS was successfully poisoned!!! cb: %s -------\n%s\n", cb, request.URL)
		result = checkPoisoningIndicators(result, request, msg, "", "", statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)
	}

	return result
}

/* HTTP Meta Character */
func hmc(client http.Client, result Result) Result {

	//TODO: Change to other header, which is probably whitelisted
	headers := []string{"X-Metachar-Header"}
	values := []string{"\\n", "\\r", "\\a", "\\0", "\\b", "\\e", "\\v", "\\f", "\\u0000"}

	for _, header := range headers {
		result = headerDOSTemplate(client, result, values, header, "HMC ")
	}

	return result
}

/* HTTP Method Override Attack */
func hmo(client http.Client, result Result) Result {

	values := []string{"GET", "POST", "DELETE", "NONSENSE"}
	headers := []string{"X-HTTP-Method-Override", "X-HTTP-Method", "X-Method-Override"}

	for _, header := range headers {
		result = headerDOSTemplate(client, result, values, header, "HMO ")
	}

	return result
}

func headerDOSTemplate(client http.Client, result Result, values []string, header string, msgextra string) Result {
	msg := fmt.Sprintf("Testing now %sDOS with header %s and values %s\n", msgextra, header, values)
	Print(msg, NoColor)

	//c := make(chan result) //<- needed?
	sem := make(chan int, Config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(values))

	results := []Result{}

	for _, value := range values {

		go func(value string) {
			defer wg.Done()
			sem <- 1

			//msg := fmt.Sprintf("Testing now %s Header DOS with %s\n", header, value)
			//Print(msg, NoColor)

			urlCb, cb := addCacheBuster(Config.Website.Url.String(), "", Config.CacheBuster)

			identifier := fmt.Sprintf("%s%s with %s", msgextra, header, value)
			_, statusCode1, request, _, timeOut1, err := firstRequest(client, urlCb, identifier, []string{header}, []string{value}, "", false)
			if err != nil && !timeOut1 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			//TODO: Check first request, if second is necessary?
			body, statusCode2, respHeader, timeOut2, err := secondRequest(client, urlCb, identifier)
			if err != nil && !timeOut2 {
				if err.Error() != "stop" {
					result.HasError = true
					result.ErrorMessage += err.Error()
				}
				<-sem
				return
			}

			msg = fmt.Sprintf("------- %sDOS with header %s and value %s was poisoned!!! cb: %s -------\n%s\n", msgextra, header, value, cb, request.URL)
			tempResult := checkPoisoningIndicators(result, request, msg, string(body), "", statusCode1, statusCode2, respHeader, timeOut1 && timeOut2)
			if tempResult.Vulnerable || tempResult.HasError {
				results = append(results, tempResult)
			}

			<-sem
		}(value)
	}

	// Because of race condition while multithreading the results needs to be collected in a slice and afterwards analyzed
	for _, x := range results {
		if x.HasError {
			result.HasError = x.HasError
			result.ErrorMessage += x.ErrorMessage
		}
		if x.Vulnerable {
			result.Vulnerable = x.Vulnerable
			result.Requests = append(result.Requests, x.Requests...)
		}
	}

	return result
}

func firstRequest(client http.Client, urlCb string, identifier string, header []string, value []string, bodyString string, forcePost bool) ([]byte, int, Request, http.Header, bool, error) {
	var req *http.Request
	var err error
	var msg string
	var body []byte
	var request Request
	timeOut := false

	if len(header) != len(value) {
		msg = "len(header) != len(value)"
		Print(msg, Red)
		return body, -1, request, nil, timeOut, errors.New(msg)
	}

	if value[0] == "2ndrequest" {
		identifier = fmt.Sprintf("2nd request of %s\n", identifier)
	} else {
		identifier = fmt.Sprintf("1st request of %s", identifier)
	}

	if Config.DoPost || forcePost {
		bodyString = Config.Body
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
	} else if bodyString != "" {
		req, err = http.NewRequest("GET", urlCb, bytes.NewBufferString(bodyString))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg = identifier + err.Error() + "\n"
		Print(msg, Red)
		return body, -1, request, nil, timeOut, errors.New(msg)
	}

	setRequest(req, Config.DoPost)

	for i := range header {
		if strings.EqualFold(header[i], "Host") {
			newHost := req.URL.Host + value[i]
			msg := fmt.Sprintf("Overwriting Host:%s with Host:%s\n", req.URL.Host, newHost)
			PrintVerbose(msg, NoColor, 1)
			req.Host = newHost
		} else if header[i] != "" {
			if h := req.Header.Get(header[i]); h != "" {
				msg := fmt.Sprintf("Overwriting %s:%s with %s:%s\n", header[i], h, header[i], value[i])
				Print(msg, NoColor)
				req.Header.Set(header[i], value[i])
			} else {
				req.Header.Add(header[i], value[i])
			}
		}
	}

	request = setReportRequest(req, bodyString)

	resp, err := client.Do(req)

	if err != nil {
		timeOut = strings.Contains(err.Error(), "Client.Timeout exceeded while awaiting headers")

		msg = fmt.Sprintf("%s %s\n", identifier, err.Error())
		Print(msg, Yellow)
		return body, -1, request, nil, timeOut, errors.New(msg)
	} else {
		defer resp.Body.Close()

		body, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			msg = err.Error() + "\n"
			PrintFatal(msg)
		}

		if resp.StatusCode != Config.Website.StatusCode {
			msg = fmt.Sprintf("Unexpected Status Code %d for %s\n", resp.StatusCode, identifier)
			Print(msg, Yellow)
		}
	}

	if stopContinuation(timeOut, body, resp.StatusCode, resp.Header.Clone()) {
		return body, -1, request, nil, timeOut, errors.New(msg)
	}

	return body, resp.StatusCode, request, resp.Header.Clone(), timeOut, nil
}

func secondRequest(client http.Client, urlCb string, identifier string) ([]byte, int, http.Header, bool, error) {

	body, statusCode, _, header, timeOut, err := firstRequest(client, urlCb, identifier, []string{""}, []string{"2ndrequest"}, "", false)

	return body, statusCode, header, timeOut, err
}
