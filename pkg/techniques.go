package pkg

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"sync"
)

var impactfulQueries []string

func init() {

}

func setReportRequest(req *http.Request, body string) Request {
	var request Request
	request.Method = req.Method
	request.URL = req.URL.String()
	request.Header = req.Header
	request.Body = body

	return request
}

/* Scan cookies for poisoning */
func ScanCookies(client http.Client, config Config) Result {
	var result Result
	result.Technique = "Cookies"
	for i := 0; i < len(config.Website.Cookies); i++ {
		poison := randInt()
		msg := fmt.Sprintf("Checking cookie %s", config.Website.Cookies[i].Name)
		Print(msg, NoColor)

		urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

		errorMessage := config.Website.Cookies[i].String() + "=" + config.Website.Cookies[i].Value

		var req *http.Request
		var err error

		bodyString := ""
		if config.DoPost {
			bodyString = config.Body
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := errorMessage + err.Error() + "\n"
			PrintFatal(msg)
		}

		msg = fmt.Sprintf("Overwriting %s=%s with %s=%s\n", config.Website.Cookies[i].Name, config.Website.Cookies[i].Value, config.Website.Cookies[i].Name, poison)
		Print(msg, NoColor)
		oldValue := config.Website.Cookies[i].Value
		config.Website.Cookies[i].Value = poison

		setRequest(req, config.DoPost, config)

		resp, err := client.Do(req)
		if err != nil {
			msg = errorMessage + err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			msg = fmt.Sprintf("Unexpected Status Code %d for %s=%s\n", resp.StatusCode, config.Website.Cookies[i], config.Website.Cookies[i].Value)
			Print(msg, Yellow)
		}

		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			msg = errorMessage + err.Error() + "\n"
			PrintFatal(msg)
		}

		config.Website.Cookies[i].Value = oldValue

		//TODO: Compare (at first) ContentLength instead of whole body?
		if string(body) == config.Website.Body {
			continue
		}

		request := setReportRequest(req, bodyString)

		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg = errorMessage + err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)
		resp, err = client.Do(req)
		if err != nil {
			msg = errorMessage + err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			msg = fmt.Sprintf("Unexpected Status Code %d for %s=%s\n", resp.StatusCode, config.Website.Cookies[i], config.Website.Cookies[i].Value)
			Print(msg, Yellow)
		}

		body, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			msg = errorMessage + err.Error() + "\n"
			PrintFatal(msg)
		}

		if strings.Contains(string(body), poison) {
			msg = fmt.Sprintf("------- Cookie %s was successfully poisoned!!! cb: %s poison: %s -------\n%s\n", config.Website.Cookies[i].Name, cb, poison, req.URL)
			Print(msg, Green)

			result.Vulnerable = true
			result.Requests = append(result.Requests, request)
		}
	}
	return result
}

/* Scan X-Forwarded headers for poisoning */
func ScanXForwardedHeaders(client http.Client, config Config) Result {
	var result Result
	result.Technique = "X-Forwarded"

	poison := randInt()

	urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

	var req *http.Request
	var err error

	bodyString := ""
	if config.DoPost {
		bodyString = config.Body
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)

	if h := req.Header.Get("X-Forwarded-Host"); h != "" {
		msg := fmt.Sprintln("Overwriting X-Forwarded-Host" + ":" + h + " with X-Forwarded-Host:" + poison)
		Print(msg, NoColor)
		req.Header.Set("X-Forwarded-Host", poison)
	} else {
		req.Header.Add("X-Forwarded-Host", poison)
	}
	if h := req.Header.Get("X-Forwarded-Scheme"); h != "" {
		msg := fmt.Sprintln("Overwriting X-Forwarded-Scheme" + ":" + h + " with X-Forwarded-Scheme:nothttps")
		Print(msg, NoColor)
		req.Header.Set("X-Forwarded-Scheme", "nothttps")
	} else {
		req.Header.Add("X-Forwarded-Scheme", "nothttps")
	}

	resp, err := client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	request := setReportRequest(req, bodyString)

	//TODO: Check first request, if second is necessary?
	if config.DoPost {
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)
	resp, err = client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	if strings.Contains(resp.Header.Get("Location"), poison) || strings.Contains(req.Host, poison) {
		msg := fmt.Sprintf("------- X-Forwarded-Host and X-Forwarded-Scheme was successfully poisoned!!! cb: %s poison: %s-------\n%s\n", cb, poison, req.URL)
		Print(msg, Green)

		result.Vulnerable = true
		result.Requests = append(result.Requests, request)
	}

	return result
}

/* Scan Host header for poisoning */
func ScanHostHeader(client http.Client, config Config) Result {
	var result Result
	result.Technique = "Host"

	headers := []string{":", ":@", " "}

	for _, header := range headers {

		poison := randInt()

		urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

		var req *http.Request
		var err error

		bodyString := ""
		if config.DoPost {
			bodyString = config.Body
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)

		newHost := req.URL.Host + header + "123"
		msg := fmt.Sprintf("Overwriting Host:%s with Host:%s\n", req.URL.Host, newHost)
		PrintVerbose(msg, NoColor, 1)

		req.Host = newHost

		resp, err := client.Do(req)

		timeoutCount := 0
		if err != nil && strings.Contains(err.Error(), "Client.Timeout exceeded while awaiting headers") {
			timeoutCount++
		} else if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		} else {
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
				Print(msg, Yellow)
			}
		}

		request := setReportRequest(req, bodyString)

		//TODO: Check first request, if second is necessary?
		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)
		resp, err = client.Do(req)

		var body []byte
		if err != nil && strings.Contains(err.Error(), "Client.Timeout exceeded while awaiting headers") {
			timeoutCount++
		} else if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		} else {
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
				Print(msg, Yellow)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				msg = err.Error() + "\n"
				PrintFatal(msg)
			}
		}

		if strings.Contains(string(body), poison) || resp.StatusCode != config.Website.StatusCode || timeoutCount == 2 {
			msg := fmt.Sprintf("------- Host was successfully poisoned!!! cb: %s poison: %s-------\n%s\n", cb, poison, req.URL)
			Print(msg, Green)

			result.Vulnerable = true
			result.Requests = append(result.Requests, request)
		}
	}

	return result
}

/* Scan Forwarded header for poisoning */
func ScanForwardedHeader(client http.Client, config Config) Result {
	var result Result
	result.Technique = "Forwarded"

	poison := randInt()

	urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

	var req *http.Request
	var err error

	bodyString := ""
	if config.DoPost {
		bodyString = config.Body
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)

	headerValue := "host=" + poison
	if h := req.Header.Get("Forwarded"); h != "" {
		msg := fmt.Sprintln("Overwriting Forwarded" + ":" + h + " with Forwarded:" + headerValue)
		Print(msg, NoColor)
		req.Header.Set("Forwarded", headerValue)
	} else {
		req.Header.Add("Forwarded", headerValue)
	}

	resp, err := client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	request := setReportRequest(req, bodyString)

	//TODO: Check first request, if second is necessary?
	if config.DoPost {
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)
	resp, err = client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	if strings.Contains(string(body), poison) || resp.StatusCode == 400 {
		msg := fmt.Sprintf("------- Forwarded was successfully poisoned!!! cb: %s poison: %s-------\n%s\n", cb, poison, req.URL)
		Print(msg, Green)

		result.Vulnerable = true
		result.Requests = append(result.Requests, request)
	}

	return result
}

/* Scan Forwarded header for poisoning */
func ScanXForwardedPortHeader(client http.Client, config Config) Result {
	var result Result
	result.Technique = "X-Forwarded-Port"

	poison := randInt()

	urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

	var req *http.Request
	var err error

	bodyString := ""
	if config.DoPost {
		bodyString = config.Body
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)

	if h := req.Header.Get("X-Forwarded-Port"); h != "" {
		msg := fmt.Sprintln("Overwriting X-Forwarded-Port" + ":" + h + " with X-Forwarded-Port:" + poison)
		Print(msg, NoColor)
		req.Header.Set("X-Forwarded-Port", poison)
	} else {
		req.Header.Add("X-Forwarded-Port", poison)
	}

	resp, err := client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	request := setReportRequest(req, bodyString)

	//TODO: Check first request, if second is necessary?
	if config.DoPost {
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)
	resp, err = client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	if strings.Contains(string(body), poison) || resp.StatusCode == 400 {
		msg := fmt.Sprintf("------- X-Forwarded-Port was successfully poisoned!!! cb: %s poison: %s-------\n%s\n", cb, poison, req.URL)
		Print(msg, Green)

		result.Vulnerable = true
		result.Requests = append(result.Requests, request)
	}

	return result
}

/* Scan headers for poisoning */
func ScanHeaders(client http.Client, headerList []string, config Config) Result {
	var result Result
	result.Technique = "Headers"

	//c := make(chan result) //<- needed?
	sem := make(chan int, config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(headerList))

	for i, s := range headerList {
		s = strings.Trim(s, "\r")
		if s == "" {
			msg := fmt.Sprintf("Skipping empty header (%d/%d)\n", i+1, len(headerList))
			PrintVerbose(msg, NoColor, 1)

			wg.Done()
			continue
		}

		s = http.CanonicalHeaderKey(s)

		poison := randInt()

		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			msg := fmt.Sprintf("Testing now (%d/%d) %s\n", i+1, len(headerList), s)
			PrintVerbose(msg, NoColor, 2)

			urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)
			var req *http.Request
			var err error
			bodyString := ""
			if config.DoPost {
				bodyString = config.Body
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				<-sem
				msg := s + err.Error()
				Print(msg, Yellow)
			}

			setRequest(req, config.DoPost, config)

			if h := req.Header.Get(s); h != "" {
				msg = fmt.Sprintf("Overwriting %s:%s with %s:%s\n", s, h, s, poison)
				PrintVerbose(msg, NoColor, 1)
				req.Header.Set(s, poison)
			} else {
				req.Header.Add(s, poison)
			}

			resp, err := client.Do(req)
			if err != nil {
				<-sem
				msg := s + err.Error()
				Print(msg, Yellow)
				return
			}
			request := setReportRequest(req, bodyString)

			if resp.StatusCode != config.Website.StatusCode {
				msg = fmt.Sprintf("Unexpected Status Code %d for header %s=%s\n", resp.StatusCode, s, poison)
				Print(msg, Yellow)
			}

			defer resp.Body.Close()
			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			if string(body) == config.Website.Body {
				<-sem
				return
			}

			if config.DoPost {
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				msg = fmt.Sprintf("Unexpected Status Code %d for header %s\n", resp.StatusCode, s)
				Print(msg, Yellow)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			if strings.Contains(string(body), poison) {
				msg = fmt.Sprintf("------- Header %s was successfully poisoned!!! cb: %s poison: %s -------\n%s\n", s, cb, poison, req.URL)
				Print(msg, Green)

				result.Vulnerable = true
				result.Requests = append(result.Requests, request)
			}

			<-sem
		}(i, s, poison)

	}
	wg.Wait()

	return result
}

/* Scan query parameters for poisoning */
func ScanParameters(client http.Client, parameterList []string, config Config) Result {
	var result Result
	result.Technique = "Parameters"

	//c := make(chan result) //<- needed?
	sem := make(chan int, config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(parameterList))

	impactfulQueries = nil

	for i, s := range parameterList {
		if s == "" {
			msg := fmt.Sprintf("Skipping empty query (%d/%d) %s\n", i+1, len(parameterList), s)
			PrintVerbose(msg, NoColor, 2)
			wg.Done()
			continue
		}

		poison := randInt()

		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			s = strings.Trim(s, "\r")

			msg := fmt.Sprintf("Testing now Parameter (%d/%d) %s\n", i+1, len(parameterList), s)
			PrintVerbose(msg, NoColor, 2)

			var urlCb, cb string
			if _, ok := config.Website.Queries[s]; ok {
				// if the query to add is already present
				queryParameterMap := make(map[string]string)

				for key, val := range config.Website.Queries {
					queryParameterMap[key] = val
				}

				msg := fmt.Sprintf("Overwriting %s=%s with %s=%s\n", s, queryParameterMap[s], s, poison)
				Print(msg, NoColor)
				queryParameterMap[s] = poison

				urlCb = config.Website.BaseUrlStr + "?"
				for key, val := range queryParameterMap {
					if !strings.HasSuffix(urlCb, "?") {
						urlCb += "&"
					}
					urlCb += key + "=" + val
				}

				urlCb, cb = addCacheBuster(urlCb+config.QuerySeperator, "", config.CacheBuster)
			} else {
				// if query isn't already present, just add it and the cachebuster
				urlCb = config.Website.Url.String()
				urlCb += s + "=" + poison + config.QuerySeperator
				urlCb, cb = addCacheBuster(urlCb, "", config.CacheBuster)
			}

			var req *http.Request
			var err error
			bodyString := ""
			if config.DoPost {
				bodyString := config.Body
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			setRequest(req, config.DoPost, config)
			resp, err := client.Do(req)
			if err != nil {
				<-sem
				msg := s + err.Error()
				Print(msg, Yellow)
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				msg := fmt.Sprintf("Unexpected Status Code %d for parameter %s=%s\n", resp.StatusCode, s, poison)
				Print(msg, Yellow)
			}

			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			// check if something changed
			if string(body) == config.Website.Body {
				<-sem
				return
			}

			request := setReportRequest(req, bodyString)

			impactfulQueries = append(impactfulQueries, s)

			// get urlCb with the cachebuster but without the poisoned query
			urlCb, cb = addCacheBuster(config.Website.Url.String(), cb, config.CacheBuster)

			if config.DoPost {
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				msg := fmt.Sprintf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
				Print(msg, Yellow)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			if strings.Contains(string(body), poison) {
				msg := fmt.Sprintf("------- Query Parameter %s was successfully poisoned!!! cb: %s poison: %s -------\n%s\n", s, cb, poison, req.URL)
				Print(msg, Green)

				result.Vulnerable = true
				result.Requests = append(result.Requests, request)
			}

			<-sem
		}(i, s, poison)

	}
	wg.Wait()

	return result
}

/* Check for fat GET */
func ScanFatGET(client http.Client, config Config) Result {
	var result Result
	result.Technique = "Fat GET"

	if len(impactfulQueries) == 0 {
		errMsg := "No impactful query parameters were found beforehand. Run the query parameter scan (maybe with a different wordlist)."
		Print(errMsg+"\n", Yellow)
		result.HasError = true
		result.ErrorMessage = errMsg
		return result
	} else {
		msg := fmt.Sprintf("The following parameters were found to be impactful and will be tested for parameter cloaking: %s\n", impactfulQueries)
		Print(msg, NoColor)
	}

	//c := make(chan result) //<- needed?
	sem := make(chan int, config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(impactfulQueries))

	msg := "\nTesting now simple Fat GET\n"
	Print(msg, NoColor)

	for i, s := range impactfulQueries {

		poison := randInt()

		// basic fat get technique
		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			msg = fmt.Sprintf("(%d/%d) %s\n", i+1, len(impactfulQueries), s)
			PrintVerbose(msg, NoColor, 2)

			urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

			var req *http.Request
			var err error

			bodyString := s + "=" + poison
			req, err = http.NewRequest("GET", urlCb, bytes.NewBufferString(bodyString))
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			setRequest(req, config.DoPost, config)
			resp, err := client.Do(req)
			if err != nil {
				<-sem
				msg := s + err.Error()
				Print(msg, Yellow)
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				msg := fmt.Sprintf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
				Print(msg, Yellow)
			}

			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			// check if something changed
			if string(body) == config.Website.Body {
				<-sem
				return
			}

			request := setReportRequest(req, bodyString)

			// get urlCb with the cachebuster but without the poisoned query
			urlCb, cb = addCacheBuster(config.Website.Url.String(), cb, config.CacheBuster)

			req, err = http.NewRequest("GET", urlCb, nil)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				msg := fmt.Sprintf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
				Print(msg, Yellow)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			if strings.Contains(string(body), poison) {
				msg := fmt.Sprintf("------- Query Parameter %s was successfully poisoned via simple fat GET!!! cb: %s poison:%s -------\n%s\n", s, cb, poison, req.URL)
				Print(msg, Green)

				result.Vulnerable = true
				result.Requests = append(result.Requests, request)
			}

			<-sem
		}(i, s, poison)
	}
	wg.Wait()
	wg.Add(len(impactfulQueries))

	headers := []string{"X-HTTP-Method-Override", "X-HTTP-Method", "X-Method-Override"}

	for _, header := range headers {
		msg = fmt.Sprintf("\nTesting now %s Fat GET\n", header)
		Print(msg, NoColor)

		for i, s := range impactfulQueries {

			poison := randInt()

			// X-HTTP-Method-Override fat get technique
			go func(i int, s string, poison string) {
				defer wg.Done()
				sem <- 1

				msg = fmt.Sprintf("(%d/%d) %s\n", i+1, len(impactfulQueries), s)
				PrintVerbose(msg, NoColor, 2)

				urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

				var req *http.Request
				var err error

				bodyString := s + "=" + poison
				req, err = http.NewRequest("GET", urlCb, bytes.NewBufferString(bodyString))
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}

				//true so ContentType will be set
				setRequest(req, true, config)

				if h := req.Header.Get(header); h != "" {
					msg = fmt.Sprintf("Overwriting %s: %s with %s:%s\n", header, h, header, poison)
					Print(msg, NoColor)
					req.Header.Set(header, "POST")
				} else {
					req.Header.Add(header, "POST")
				}

				resp, err := client.Do(req)
				if err != nil {
					<-sem
					msg := s + err.Error()
					Print(msg, Yellow)
					return
				}
				defer resp.Body.Close()

				if resp.StatusCode != config.Website.StatusCode {
					msg = fmt.Sprintf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
					Print(msg, Yellow)
				}

				body, err := ioutil.ReadAll(resp.Body)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}

				// check if something changed
				if string(body) == config.Website.Body {
					<-sem
					return
				}

				request := setReportRequest(req, bodyString)

				// get urlCb with the cachebuster but without the poisoned query
				urlCb, cb = addCacheBuster(config.Website.Url.String(), cb, config.CacheBuster)

				req, err = http.NewRequest("GET", urlCb, nil)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}

				setRequest(req, config.DoPost, config)
				resp, err = client.Do(req)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}
				defer resp.Body.Close()

				if resp.StatusCode != config.Website.StatusCode {
					msg = fmt.Sprintf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
					Print(msg, Yellow)
				}

				body, err = ioutil.ReadAll(resp.Body)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}

				if strings.Contains(string(body), poison) {
					msg = fmt.Sprintf("------- Query Parameter %s was successfully poisoned via %s fat GET!!! cb:%s poison:%s-------\n%s\n", s, header, cb, poison, req.URL)
					Print(msg, Green)

					result.Vulnerable = true
					result.Requests = append(result.Requests, request)
				}

				<-sem
			}(i, s, poison)
		}
		wg.Wait()
		wg.Add(len(impactfulQueries))
	}

	msg = "\nTesting now POST Fat GET\n"
	Print(msg, NoColor)

	for i, s := range impactfulQueries {

		poison := randInt()

		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			msg = fmt.Sprintf("(%d/%d) %s\n", i+1, len(impactfulQueries), s)
			PrintVerbose(msg, NoColor, 2)

			urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

			var req *http.Request
			var err error

			bodyString := s + "=" + poison
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			// True so ContentType will be set
			setRequest(req, true, config)

			resp, err := client.Do(req)
			if err != nil {
				<-sem
				msg := s + err.Error()
				Print(msg, Yellow)
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				msg = fmt.Sprintf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
				Print(msg, Yellow)
			}

			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			// check if something changed
			if string(body) == config.Website.Body {
				<-sem
				return
			}

			request := setReportRequest(req, bodyString)

			// get urlCb with the cachebuster but without the poisoned query
			urlCb, cb = addCacheBuster(config.Website.Url.String(), cb, config.CacheBuster)

			req, err = http.NewRequest("GET", urlCb, nil)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				msg = fmt.Sprintf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
				Print(msg, Yellow)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				msg := s + err.Error() + "\n"
				PrintFatal(msg)
			}

			if strings.Contains(string(body), poison) {
				msg = fmt.Sprintf("------- Query Parameter %s was successfully poisoned via simple fat GET!!! cb:%s poison:%s -------\n%s\n", s, cb, poison, req.URL)
				Print(msg, Green)

				result.Vulnerable = true
				result.Requests = append(result.Requests, request)
			}

			<-sem
		}(i, s, poison)

	}
	wg.Wait()

	return result
}

/* Check for Parameter Cloaking */
func ScanParameterCloaking(client http.Client, config Config) Result {
	var result Result
	result.Technique = "Parameter Cloaking"

	if len(impactfulQueries) == 0 {
		errMsg := "No impactful query parameters were found beforehand. Run the query parameter scan (maybe with a different wordlist)."
		Print(errMsg+"\n", Yellow)
		result.HasError = true
		result.ErrorMessage = errMsg
		return result
	} else {
		msg := fmt.Sprintf("The following parameters were found to be impactful and will be tested for parameter cloaking:\n%s\n", impactfulQueries)
		Print(msg, NoColor)
	}

	utm_parameter := []string{"utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"}
	unkeyed_parameter := []string{}

	urlCb, _ := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

	var req *http.Request
	var err error

	/***********Check if urlCb already contains utm parameter.
				Check if ? or querySeperator is needed
	****************/

	// The first request is made so a cache miss is forced and the following responses will only
	//have a cache hit, if they are unkeyed
	req, err = http.NewRequest("GET", urlCb, nil)
	if err != nil {
		msg := fmt.Sprintf("first request: %s\n", err)
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)
	resp, err := client.Do(req)
	if err != nil {
		msg := fmt.Sprintf("first request: %s\n", err)
		Print(msg, Yellow)
		result.HasError = true
		result.ErrorMessage = "first request: " + err.Error()
		return result
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d for first request\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	sem := make(chan int, config.Threads)
	var wg sync.WaitGroup

	if config.Website.Cache.Indicator == "" {
		//Cant test if utm_parameter are unkeyed if X-Cache isn't set
		//So they will be all added as unkeyed_parameter
		msg := "hit/miss isn't verbose. Can't check which utm_parameter is unkeyed, so all will be used\n"
		Print(msg, Yellow)
		unkeyed_parameter = utm_parameter
	} else {
		//Test which utm_parameter are unkeyed
		//c := make(chan result) //<- needed?

		wg.Add(len(utm_parameter))
		for i, s := range utm_parameter {
			go func(i int, s string) {
				defer wg.Done()
				sem <- 1

				msg := fmt.Sprintf("Testing now for unkeyed utm parameters (%d/%d) %s\n", i+1, len(utm_parameter), s)
				PrintVerbose(msg, NoColor, 2)

				var req *http.Request
				var err error

				// add utm parameter after cachebuster. give utm parameter nonsense value
				req, err = http.NewRequest("GET", urlCb+config.QuerySeperator+s+"=foobar", nil)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}

				setRequest(req, config.DoPost, config)
				resp, err := client.Do(req)
				if err != nil {
					<-sem
					msg := s + err.Error()
					Print(msg, Yellow)
					return
				}
				defer resp.Body.Close()

				if resp.StatusCode != config.Website.StatusCode {
					msg = fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
					Print(msg, Yellow)
				}

				if strings.ToLower(resp.Header.Get(config.Website.Cache.Indicator)) == "hit" {
					unkeyed_parameter = append(unkeyed_parameter, s)
				}

			}(i, s)
		}
		wg.Wait()
	}

	if len(unkeyed_parameter) == 0 {
		msg := "No unkeyed utm parameters could be found. Parameter Cloaking is not possible using utm parameters\n"
		Print(msg, Yellow)
	} else {
		msg := fmt.Sprintf("The following utm parameters were found to be unkeyed and will be tested for parameter cloaking:\n %s\n", unkeyed_parameter)
		Print(msg, NoColor)
	}

	cloak := ";"
	if config.QuerySeperator == ";" {
		cloak = "&"
	}

	for iu, u := range unkeyed_parameter {

		//test one unkeyed parameter with all impactfulQueries one after another
		wg.Add(len(impactfulQueries))

		for is, s := range impactfulQueries {

			poison := randInt()

			go func(iu int, u string, is int, s string, poison string) {
				defer wg.Done()
				sem <- 1

				msg := fmt.Sprintf("Testing now Parameter Cloaking (%d/%d) %s%s%s\n", iu+is+1, len(impactfulQueries)*len(unkeyed_parameter), u, cloak, s)
				PrintVerbose(msg, NoColor, 2)

				urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

				var req *http.Request
				var err error

				req, err = http.NewRequest("GET", urlCb+config.QuerySeperator+u+"=foobar"+cloak+s+"="+poison, nil)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}

				setRequest(req, config.DoPost, config)
				resp, err := client.Do(req)
				if err != nil {
					<-sem
					msg := s + err.Error()
					Print(msg, Yellow)
					return
				}
				defer resp.Body.Close()

				if resp.StatusCode != config.Website.StatusCode {
					msg = fmt.Sprintf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
					Print(msg, Yellow)
				}

				body, err := ioutil.ReadAll(resp.Body)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}

				// check if something changed
				if string(body) == config.Website.Body {
					<-sem
					return
				}

				request := setReportRequest(req, "")

				// get urlCb with the cachebuster but without the poisoned query
				urlCb, cb = addCacheBuster(config.Website.Url.String(), cb, config.CacheBuster)

				req, err = http.NewRequest("GET", urlCb, nil)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}

				setRequest(req, config.DoPost, config)
				resp, err = client.Do(req)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}
				defer resp.Body.Close()

				if resp.StatusCode != config.Website.StatusCode {
					msg = fmt.Sprintf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
					Print(msg, Yellow)
				}

				body, err = ioutil.ReadAll(resp.Body)
				if err != nil {
					<-sem
					msg := s + err.Error() + "\n"
					PrintFatal(msg)
				}

				if strings.Contains(string(body), poison) {
					msg = fmt.Sprintf("------- Query Parameter %s was successfully poisoned via Parameter Cloaking using %s!!! cb:%s poison:%s -------\n%s\n", s, u, cb, poison, req.URL)
					Print(msg, Green)

					result.Vulnerable = true
					result.Requests = append(result.Requests, request)
				}

				<-sem
			}(iu, u, is, s, poison)
		}
		wg.Wait()
	}

	return result
}

/* Check for different DOS techniques */
func DOS(client http.Client, config Config) Result {
	var result Result
	result.Technique = "DOS"

	// TODO: Ist nur Header Value oder auch Header Name ausschlaggebend?
	result = hho(client, config, result)

	// TODO: Check for more META CHARACTERS?
	result = hmc(client, config, result)

	// TODO: Add more HEADERS/METHODS?
	result = hmo(client, config, result)

	// TODO: Add more BLACKLIST WORDS?
	result = blacklist(client, config, result)

	// TODO: Add more USERAGENTS?
	result = incompatibleBrowser(client, config, result)

	result = transferEncoding(client, config, result)

	result = rangeHeader(client, config, result)

	result = xForwardedProtocolHeader(client, config, result)

	result = xForwardedSSLHeader(client, config, result)

	result = maxForwardsHeader(client, config, result)

	return result
}

/* HTTP Header Oversize */
func hho(client http.Client, config Config, result Result) Result {

	repetitions := []int{50, 100, 200} //4k, 8k, 16k

	for _, repetition := range repetitions {
		msg := fmt.Sprintf("Testing now HHO with Size Limit %dk bytes\n", repetition*8/100)
		Print(msg, NoColor)

		urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

		var req *http.Request
		var err error

		bodyString := ""
		if config.DoPost {
			bodyString = config.Body
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)

		for i := 1; i < repetition; i++ {
			headername := fmt.Sprintf("X-Oversized-Header-%d", i)
			req.Header.Add(headername, "Big-Value-000000000000000000000000000000000000000000000000000000000000000000000000000000")
		}

		resp, err := client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		status1 := false
		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
			status1 = true
		}

		request := setReportRequest(req, bodyString)

		//TODO: Check first request, if second is necessary?
		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)
		resp, err = client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		status2 := false
		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
			status2 = true
		}

		if status1 && status2 {
			msg := fmt.Sprintf("------- HHO DOS was successfully poisoned!!! cb: %s -------\n%s\n", cb, req.URL)
			Print(msg, Green)

			result.Vulnerable = true
			result.Requests = append(result.Requests, request)
		}
	}

	return result
}

/* HTTP Meta Character */
func hmc(client http.Client, config Config, result Result) Result {

	metachars := []string{"\\n", "\\r", "\\a", "\\0"}

	for _, metachar := range metachars {
		msg := fmt.Sprintf("Testing now HMC %s\n", metachar)
		Print(msg, NoColor)

		urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

		var req *http.Request
		var err error

		bodyString := ""
		if config.DoPost {
			bodyString = config.Body
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)

		req.Header.Add("X-Metachar-Header", metachar)

		resp, err := client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		status1 := false
		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
			status1 = true
		}

		request := setReportRequest(req, bodyString)

		//TODO: Check first request, if second is necessary?
		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)
		resp, err = client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		status2 := false
		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
			status2 = true
		}

		if status1 && status2 {
			msg := fmt.Sprintf("------- HHO DOS was successfully poisoned!!! cb: %s -------\n%s\n", cb, req.URL)
			Print(msg, Green)

			result.Vulnerable = true
			result.Requests = append(result.Requests, request)
		}
	}

	return result
}

/* HTTP Method Override Attack */
func hmo(client http.Client, config Config, result Result) Result {

	methods := []string{"GET", "POST", "DELETE", "NONSENSE"}
	headers := []string{"X-HTTP-Method-Override", "X-HTTP-Method", "X-Method-Override"}

	for _, header := range headers {
		for _, method := range methods {
			msg := fmt.Sprintf("Testing now HMO DOS %s %s\n", header, method)
			Print(msg, NoColor)

			urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

			var req *http.Request
			var err error

			bodyString := ""
			if config.DoPost {
				bodyString = config.Body
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				msg := err.Error() + "\n"
				PrintFatal(msg)
			}

			setRequest(req, config.DoPost, config)

			req.Header.Add(header, method)

			resp, err := client.Do(req)
			if err != nil {
				msg := err.Error() + "\n"
				PrintFatal(msg)
			}
			defer resp.Body.Close()

			status1 := false
			if resp.StatusCode != config.Website.StatusCode {
				msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
				Print(msg, Yellow)
				status1 = true
			}

			request := setReportRequest(req, bodyString)

			//TODO: Check first request, if second is necessary?
			if config.DoPost {
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				msg := err.Error() + "\n"
				PrintFatal(msg)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				msg := err.Error() + "\n"
				PrintFatal(msg)
			}
			defer resp.Body.Close()

			status2 := false
			if resp.StatusCode != config.Website.StatusCode {
				msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
				Print(msg, Yellow)
				status2 = true
			}

			if status1 && status2 {
				msg := fmt.Sprintf("------- HHO DOS was successfully poisoned!!! cb: %s -------\n%s\n", cb, req.URL)
				Print(msg, Green)

				result.Vulnerable = true
				result.Requests = append(result.Requests, request)
			}
		}
	}

	return result
}

/* DOS via waf blocking because of a blacklist word */
func blacklist(client http.Client, config Config, result Result) Result {

	blacklists := []string{".burpcollaborator.net", "<script>alert(1)</script>"}

	for _, blacklist := range blacklists {
		msg := fmt.Sprintf("Testing now blacklist DOS %s\n", blacklist)
		Print(msg, NoColor)

		urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

		var req *http.Request
		var err error

		bodyString := ""
		if config.DoPost {
			bodyString = config.Body
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)

		req.Header.Add("Any-Header", blacklist)

		resp, err := client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		status1 := false
		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
			status1 = true
		}
		request := setReportRequest(req, bodyString)

		//TODO: Check first request, if second is necessary?
		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)
		resp, err = client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		status2 := false
		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
			status2 = true
		}

		if status1 && status2 {
			msg := fmt.Sprintf("------- Blacklist DOS using %s was successfully poisoned!!! cb: %s -------\n%s\n", blacklist, cb, req.URL)
			Print(msg, Green)

			result.Vulnerable = true
			result.Requests = append(result.Requests, request)
		}
	}

	return result
}

/* DOS via waf blocking because of a blacklist word */
func incompatibleBrowser(client http.Client, config Config, result Result) Result {

	browsers := []string{"Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US))"}

	for _, browser := range browsers {
		msg := fmt.Sprintf("Testing now browser DOS %s\n", browser)
		Print(msg, NoColor)

		urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

		var req *http.Request
		var err error

		bodyString := ""
		if config.DoPost {
			bodyString = config.Body
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)

		if h := req.Header.Get("User-Agent"); h != "" {
			msg = fmt.Sprintf("Overwriting User-Agent:%s with User-Agent:%s\n", h, browser)
			PrintVerbose(msg, NoColor, 1)
			req.Header.Set("User-Agent", browser)
		} else {
			req.Header.Add("User-Agent", browser)
		}

		resp, err := client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
		}

		request := setReportRequest(req, bodyString)

		//TODO: Check first request, if second is necessary?
		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)
		resp, err = client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
		}

		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			msg = err.Error() + "\n"
			PrintFatal(msg)
		}

		if string(body) != config.Website.Body {
			msg := fmt.Sprintf("------- Incompatible Browser DOS using %s was *MAYBE* poisoned!!! cb: %s -------\n%s\n", browser, cb, req.URL)
			Print(msg, Green)

			result.Vulnerable = true
			result.Requests = append(result.Requests, request)
		}
	}

	return result
}

/* DOS via not implemented transferEncoding */
func transferEncoding(client http.Client, config Config, result Result) Result {

	msg := "Testing now transfer encoding DOS\n"
	Print(msg, NoColor)

	urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

	var req *http.Request
	var err error

	bodyString := ""
	if config.DoPost {
		bodyString = config.Body
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)

	poison := randInt()
	if h := req.Header.Get("zTRANSFER-ENCODING"); h != "" {
		msg = fmt.Sprintf("Overwriting zTRANSFER-ENCODING:%s with zTRANSFER-ENCODING:%s\n", h, poison)
		PrintVerbose(msg, NoColor, 1)
		req.Header.Set("zTRANSFER-ENCODING", poison)
	} else {
		req.Header.Add("zTRANSFER-ENCODING", poison)
	}
	resp, err := client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	request := setReportRequest(req, bodyString)

	//TODO: Check first request, if second is necessary?
	if config.DoPost {
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)
	resp, err = client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		msg = err.Error() + "\n"
		PrintFatal(msg)
	}

	if strings.Contains(string(body), poison) {
		msg := fmt.Sprintf("------- Transfer encoding DOS was poisoned!!! cb: %s poison: %s -------\n%s\n", cb, poison, req.URL)
		Print(msg, Green)

		result.Vulnerable = true
		result.Requests = append(result.Requests, request)
	}

	return result
}

/* DOS via Range */
func rangeHeader(client http.Client, config Config, result Result) Result {

	msg := "Testing now Range Header DOS\n"
	Print(msg, NoColor)

	urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

	var req *http.Request
	var err error

	bodyString := ""
	if config.DoPost {
		bodyString = config.Body
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)

	if h := req.Header.Get("Range"); h != "" {
		msg = fmt.Sprintf("Overwriting Range:%s with Range:%s\n", h, "bytes=cow")
		PrintVerbose(msg, NoColor, 1)
		req.Header.Set("Range", "bytes=cow")
	} else {
		req.Header.Add("Range", "bytes=cow")
	}

	resp, err := client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	request := setReportRequest(req, bodyString)

	//TODO: Check first request, if second is necessary?
	if config.DoPost {
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)
	resp, err = client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		msg = err.Error() + "\n"
		PrintFatal(msg)
	}

	if len(string(body)) == 0 {
		msg := fmt.Sprintf("------- Transfer encoding DOS was poisoned!!! cb: %s -------\n%s\n", cb, req.URL)
		Print(msg, Green)

		result.Vulnerable = true
		result.Requests = append(result.Requests, request)
	}

	return result
}

/* DOS via Range */
func xForwardedProtocolHeader(client http.Client, config Config, result Result) Result {

	values := []string{"http", "https", "ssl", "nonesense"}

	for _, value := range values {
		msg := fmt.Sprintf("Testing now X-Forwarded-Protocol Header DOS with %s\n", value)
		Print(msg, NoColor)

		urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

		var req *http.Request
		var err error

		bodyString := ""
		if config.DoPost {
			bodyString = config.Body
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)

		if h := req.Header.Get("X-Forwarded-Protocol"); h != "" {
			msg = fmt.Sprintf("Overwriting X-Forwarded-Protocol:%s with X-Forwarded-Protocol:%s\n", h, value)
			PrintVerbose(msg, NoColor, 1)
			req.Header.Set("X-Forwarded-Protocol", value)
		} else {
			req.Header.Add("X-Forwarded-Protocol", value)
		}

		resp, err := client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
		}

		request := setReportRequest(req, bodyString)

		//TODO: Check first request, if second is necessary?
		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)
		resp, err = client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
		}

		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			msg = err.Error() + "\n"
			PrintFatal(msg)
		}

		if len(string(body)) == 0 {
			msg := fmt.Sprintf("------- X-Forwarded-Protocol DOS was poisoned!!! cb: %s -------\n%s\n", cb, req.URL)
			Print(msg, Green)

			result.Vulnerable = true
			result.Requests = append(result.Requests, request)
		}
	}
	return result
}

/* DOS via X-Fordwarded-SSL */
func xForwardedSSLHeader(client http.Client, config Config, result Result) Result {

	values := []string{"on", "off", "nonsense"}

	for _, value := range values {
		msg := fmt.Sprintf("Testing now X-Forwarded-SSL Header DOS with %s\n", value)
		Print(msg, NoColor)

		urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

		var req *http.Request
		var err error

		bodyString := ""
		if config.DoPost {
			bodyString = config.Body
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)

		if h := req.Header.Get("X-Forwarded-SS"); h != "" {
			msg = fmt.Sprintf("Overwriting X-Forwarded-SSL:%s with X-Forwarded-SSL:%s\n", h, value)
			PrintVerbose(msg, NoColor, 1)
			req.Header.Set("X-Forwarded-SSL", value)
		} else {
			req.Header.Add("X-Forwarded-SSL", value)
		}

		resp, err := client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
		}

		request := setReportRequest(req, bodyString)

		//TODO: Check first request, if second is necessary?
		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}

		setRequest(req, config.DoPost, config)
		resp, err = client.Do(req)
		if err != nil {
			msg := err.Error() + "\n"
			PrintFatal(msg)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
			Print(msg, Yellow)
		}

		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			msg = err.Error() + "\n"
			PrintFatal(msg)
		}

		if len(string(body)) == 0 {
			msg := fmt.Sprintf("------- X-Forwarded-SSL DOS was poisoned!!! cb: %s -------\n%s\n", cb, req.URL)
			Print(msg, Green)

			result.Vulnerable = true
			result.Requests = append(result.Requests, request)
		}
	}
	return result
}

/* DOS via maxFordwards Header */
func maxForwardsHeader(client http.Client, config Config, result Result) Result {

	msg := "Testing now Max-Forwards Header DOS\n"
	Print(msg, NoColor)

	urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

	var req *http.Request
	var err error

	bodyString := ""
	if config.DoPost {
		bodyString = config.Body
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(bodyString))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)

	if h := req.Header.Get("Max-Forwards"); h != "" {
		msg = fmt.Sprintf("Overwriting Max-Forwards:%s with Max-Forwards:0\n", h)
		PrintVerbose(msg, NoColor, 1)
		req.Header.Set("Max-Forwards", "0")
	} else {
		req.Header.Add("Max-Forwards", "0")
	}

	poison := randInt()
	req.Header.Add("poison", poison)

	resp, err := client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	request := setReportRequest(req, bodyString)

	//TODO: Check first request, if second is necessary?
	if config.DoPost {
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}

	setRequest(req, config.DoPost, config)
	resp, err = client.Do(req)
	if err != nil {
		msg := err.Error() + "\n"
		PrintFatal(msg)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		msg := fmt.Sprintf("Unexpected Status Code %d\n", resp.StatusCode)
		Print(msg, Yellow)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		msg = err.Error() + "\n"
		PrintFatal(msg)
	}

	if strings.Contains(string(body), poison) {
		msg := fmt.Sprintf("------- Max-Forwards DOS was poisoned!!! cb: %s -------\n%s\n", cb, req.URL)
		Print(msg, Green)

		result.Vulnerable = true
		result.Requests = append(result.Requests, request)
	}

	return result
}
