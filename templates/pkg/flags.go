package pkg

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"text/tabwriter"
)

const version = "1.0.0"

var generalOptions []FlagStruct
var requestOptions []FlagStruct
var wordlistOptions []FlagStruct

type FlagStruct struct {
	LongFlag    string
	ShortFlag   string
	Description string
}

func init() {

}

func ParseFlags(config *Config) *Config {
	/* Getting Command-line flags */

	// General Options
	/*
		var doTest string
		var dontTest string
		techniqueNames := "cookies,forward,headers,parameters,fatget,cloaking"
		var proxyCertPath string
		var proxyURL string
	*/
	techniqueNames := "cookies,forward,headers,parameters,fatget,cloaking"

	generalOptions = appendInt(generalOptions, &config.Verbosity,
		"verbosity", "v", 1, "Set verbosity. 0 = quiet, 1 = normal, 2 = verbose")
	generalOptions = appendInt(generalOptions, &config.Threads,
		"threads", "t", 20, "Threads to use. Default value is 20")
	generalOptions = appendInt(generalOptions, &config.TimeOut,
		"timeout", "to", 10, "Seconds until timeout. Default value is 10")
	generalOptions = appendInt(generalOptions, &config.Recursivity,
		"recursivity", "r", 0, "Put linked scripts/stylesheets/webpages at the end of the queue if the host is the same. Specify how deep the recursivity shall go. Default value is 0 (no recursivity)")
	generalOptions = appendString(generalOptions, &config.DoTest,
		"dotest", "dt", "", "Choose which tests to run. Use the , seperator to specify multiple ones. Example: -doTest '"+techniqueNames+"'")
	generalOptions = appendString(generalOptions, &config.DontTest,
		"donttest", "dnt", "", "Choose which tests to not run. Use the , seperator to specify multiple ones. Example: -dontTest '"+techniqueNames+"'")
	generalOptions = appendString(generalOptions, &config.ProxyCertPath,
		"proxycertpath", "ppath", "", "Path to the cert of the proxy you want to use. The cert has to have the PEM Format. Burp e.g. is in the DER Format. Use the following command to convert it: openssl x509 -inform DER -outform PEM -text -in cacert.der -out certificate.pem")
	generalOptions = appendString(generalOptions, &config.ProxyURL,
		"proxyurl", "purl", "http://127.0.0.1:8080", "Url for the proxy. Default value is http://127.0.0.1:8080")

	// Request Options

	var urlStr string
	var setCookiesStr string
	var setHeadersStr string
	var setParametersStr string
	var setBodyStr string

	requestOptions = appendString(requestOptions, &urlStr,
		"url", "u", "", "Url to scan. Has to start with http:// or https://. Otherwise use file: to specify a file with (multiple) urls. E.g. -u https://www.example.com or -u file:templates/url_list")
	requestOptions = appendBoolean(requestOptions, &config.RetrieveCookies,
		"retrieveCookies", "rc", false, "Do you want to use cookies, received in the response of the first request? Default value is false")
	requestOptions = appendString(requestOptions, &config.CacheBuster,
		"cachebuster", "cb", "cachebuster", "Specify the cachebuster to use. The default value is cachebuster")
	requestOptions = appendString(requestOptions, &setCookiesStr,
		"setcookies", "sc", "", "Set a Cookie. Otherwise use file: to specify a file with urls. E.g. -sc uid=123 or -sc file:templates/cookie_list")
	requestOptions = appendString(requestOptions, &setHeadersStr,
		"setheaders", "sh", "", "Set a Header. Otherwise use file: to specify a file with urls. E.g. -sh 'User-Agent: Safari/1.1' or -sh file:templates/header_list")
	requestOptions = appendString(requestOptions, &setParametersStr,
		"setparameters", "sp", "", "Set a Query Parameter. Otherwise use file: to specify a file with urls. E.g. -sp user=admin or -sp file:templates/parameter_list")
	requestOptions = appendString(requestOptions, &setBodyStr,
		"setbody", "sb", "", "Set the requests' body. Otherwise use file: to specify a file with urls. E.g. -sb 'admin=true' or -sh file:templates/body_file")
	requestOptions = appendBoolean(requestOptions, &config.DoPost,
		"post", "post", false, "Do a POST request instead of a GET request")
	requestOptions = appendString(requestOptions, &config.ContentType,
		"contenttype", "ct", "application/x-www-form-urlencoded", "Set the contenttype for a POST Request. Default is application/x-www-form-urlencoded. If you don't want a content-type to be used at all use -ct ''")
	requestOptions = appendInt(requestOptions, &config.StatusCode,
		"statuscode", "status", 0, "Expected status code of the responses. If not specified it takes the status code of the first response")
	requestOptions = appendString(requestOptions, &config.QuerySeperator,
		"parameterseperator", "ps", "&", "Specify the seperator for parameters. The default value is &")
	wordlistOptions = appendString(wordlistOptions, &config.HeaderWordlist,
		"headerwordlist", "hw", "wordlists/top-headers", "Wordlist for headers to test. Default path is 'wordlists/top-headers'")
	wordlistOptions = appendString(wordlistOptions, &config.QueryWordlist,
		"querywordlist", "qw", "wordlists/top-parameters", "Wordlist for query parameters to test. Default path is 'wordlists/top-parameters'")

	flag.CommandLine.Usage = help

	// flags need to be parsed, before they are used
	flag.Parse()

	/* Checking values of Flags */
	if len(flag.Args()) > 0 {
		log.Fatalln(flag.Args(), "Args are not supported! Use flags. Use -h or --help to get a list of all supported flags")
	}
	if urlStr == "" {
		log.Fatalln("No url specified. Use -url or -u. Use -h or --help to get a list of all supported flags")
	}

	/* Read URL(s) */
	if strings.HasPrefix(urlStr, "path:") {
		config.Urls = ReadLocalFile(urlStr)
	} else {
		config.Urls = append(config.Urls, urlStr)
	}

	/* Read Cookie(s) */
	if strings.HasPrefix(setCookiesStr, "path:") {
		config.Cookies = ReadLocalFile(setCookiesStr)
	} else {
		config.Cookies = append(config.Cookies, setCookiesStr)
	}

	/* Read Header(s) */
	if strings.HasPrefix(setHeadersStr, "path:") {
		config.Headers = ReadLocalFile(setHeadersStr)
	} else {
		config.Headers = append(config.Headers, setHeadersStr)
	}

	/* Read Parameter(s) */
	if strings.HasPrefix(setParametersStr, "path:") {
		config.Parameters = ReadLocalFile(setParametersStr)
	} else {
		config.Parameters = append(config.Parameters, setParametersStr)
	}

	/* Read Body */
	if strings.HasPrefix(setBodyStr, "path:") {
		bodySlice := ReadLocalFile(setBodyStr)
		for _, l := range bodySlice {
			l = strings.TrimSuffix(l, "\r")
			l = strings.TrimSpace(l)
			if strings.HasPrefix(l, "//") || l == "" {
				continue
			}
			config.Body += l
		}
	} else {
		config.Body = setBodyStr
	}

	return config
}

func help() {
	w := new(tabwriter.Writer)
	w.Init(os.Stdout, 8, 8, 0, '\t', 0)

	fmt.Println("https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner")
	fmt.Printf("version %s\n\n", version)
	fmt.Print("Usage: Web-Cache-Vulnerability-Scanner(.exe) [options]\n\n")

	fmt.Println("General Options:")
	fmt.Fprintf(w, "%s\t%s\t%s\n", "--help", "-h", "Show this help and quit")
	for _, ts := range generalOptions {
		fmt.Fprintf(w, "--%s\t-%s\t%s\n", ts.LongFlag, ts.ShortFlag, ts.Description)
	}
	w.Flush()

	fmt.Println("\nRequest Options:")
	for _, ts := range requestOptions {
		fmt.Fprintf(w, "--%s\t-%s\t%s\n", ts.LongFlag, ts.ShortFlag, ts.Description)
	}
	w.Flush()

	fmt.Println("\nWordlist Options:")
	for _, ts := range wordlistOptions {
		fmt.Fprintf(w, "--%s\t  -%s\t%s\n", ts.LongFlag, ts.ShortFlag, ts.Description)
	}
	w.Flush()

	os.Exit(0)
}

func appendString(options []FlagStruct, varString *string, longFlag string, shortFlag string, defaultValue string, description string) []FlagStruct {
	flag.StringVar(varString, longFlag, defaultValue, "")
	if shortFlag != longFlag {
		flag.StringVar(varString, shortFlag, defaultValue, "")
	}
	return append(options, FlagStruct{
		LongFlag:    longFlag,
		ShortFlag:   shortFlag,
		Description: description})
}

func appendInt(options []FlagStruct, varInt *int, longFlag string, shortFlag string, defaultValue int, description string) []FlagStruct {
	flag.IntVar(varInt, longFlag, defaultValue, "")
	if shortFlag != longFlag {
		flag.IntVar(varInt, shortFlag, defaultValue, "")
	}
	return append(options, FlagStruct{
		LongFlag:    longFlag,
		ShortFlag:   shortFlag,
		Description: description})
}

func appendBoolean(options []FlagStruct, varBoolean *bool, longFlag string, shortFlag string, defaultValue bool, description string) []FlagStruct {
	flag.BoolVar(varBoolean, longFlag, defaultValue, "")
	if shortFlag != longFlag {
		flag.BoolVar(varBoolean, shortFlag, defaultValue, "")
	}
	return append(options, FlagStruct{
		LongFlag:    longFlag,
		ShortFlag:   shortFlag,
		Description: description})
}
