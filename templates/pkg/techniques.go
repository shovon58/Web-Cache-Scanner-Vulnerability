package pkg

import (
	"bytes"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"sync"
)

func init() {

}

func CheckCache(client http.Client, config *Config) {
	/*
		Wie kann ich erkennen, dass ein Cache aktiv ist?
		- X-Cache : hit / miss
		- Zeit messen
	*/
	/*
		Was kann ich als Cache Buster benutzen?
		- Query-Parameter (cachebuster)
		- Header (z.B. origin)
	*/
}

/* Simple get request to get the body of a normal response and the cookies */
func GetWebsite(requrl string, client http.Client, retrieveCookies bool, firstRequest bool, config *Config) Website {

	queryParameterMap := make(map[string]string)

	// splitting url like {https://www.m10x.de/}?{name=max&role=admin}
	urlSlice := strings.SplitN(requrl, "?", 2)

	// splitting queries like {name=max}&{role=admin}
	var parameterSlice []string
	if strings.Contains(requrl, "?") {
		parameterSlice = strings.Split(urlSlice[1], config.QuerySeperator)
	}

	if len(parameterSlice) > 0 {
		queryParameterMap = setQueryParameterMap(queryParameterMap, parameterSlice)
	}

	if len(config.Parameters) > 0 {
		queryParameterMap = setQueryParameterMap(queryParameterMap, config.Parameters)
	}

	requrl = urlSlice[0] + "?"
	urlNoQueries := urlSlice[0]

	// adding query parameter
	for key, val := range queryParameterMap {
		if !strings.HasSuffix(requrl, "?") {
			requrl += "&"
		}
		requrl += key + "=" + val
	}

	if len(queryParameterMap) > 0 {
		requrl += config.QuerySeperator
	}

	// adding cachebuster
	requrlcb, _ := addCacheBuster(requrl, "", config.CacheBuster)

	var req *http.Request
	var err error
	if config.DoPost {
		req, err = http.NewRequest("POST", requrlcb, bytes.NewBufferString(config.Body))
	} else {
		req, err = http.NewRequest("GET", requrlcb, nil)
	}
	if err != nil {
		log.Fatalln(err)
	}

	setRequest(req, config.DoPost, config)
	resp, err := client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}

	weburl, err := url.Parse(requrl)
	if err != nil {
		log.Fatalln(err)
	}

	tempStatusCode := config.StatusCode
	if tempStatusCode == 0 {
		tempStatusCode = resp.StatusCode

		log.Printf("The default Status Code was set to %d\n", tempStatusCode)
	}

	// if retrieveCookies is false, only the specified cookies will be used
	// otherwise the by the server given cookies AND the specified cookies will be used
	cookiesWebsite := config.Website.Cookies
	if retrieveCookies {
		cookiesWebsite = append(cookiesWebsite, resp.Cookies()...)
	}

	c := Website{
		Body:       string(body),
		Cookies:    cookiesWebsite,
		StatusCode: tempStatusCode,
		Url:        weburl,
		BaseUrlStr: urlNoQueries,
		Queries:    queryParameterMap,
	}

	return c
}

func setRequest(req *http.Request, doPost bool, config *Config) {
	setRequestHeaders(req, config.Headers)
	//TODO config nötig oder nur config.Website.Cookies?
	setRequestCookies(req, config)

	// Content-Type nur hinzufügen, wenn nicht schon vorher geschehen
	if doPost {
		if req.Header.Get("Content-Type") == "" && config.ContentType != "" {
			req.Header.Add("Content-Type", config.ContentType)
		}
	}
}

/* TODO wie bei requestCookies nur die erste occurance eines headers aufnehmen */
func setRequestHeaders(req *http.Request, headers []string) {
	for _, h := range headers {
		h = strings.TrimSuffix(h, "\r")
		h = strings.TrimSpace(h)
		if h == "" {
			continue
		} else if !strings.Contains(h, ":") {
			log.Println("Specified header", h, "doesn't contain a : and will be skipped")
			continue
		} else {
			hSplitted := strings.Split(h, ":")

			req.Header.Add(strings.TrimSpace(hSplitted[0]), strings.TrimSpace(hSplitted[1]))
		}
	}
}

/* */
func setRequestCookies(req *http.Request, config *Config) {
	for i, c := range config.Website.Cookies {
		// only add first occurence of a cookie to the request
		// remove every other occurence
		_, err := req.Cookie(c.Name)
		if err == http.ErrNoCookie {
			req.AddCookie(c)
		} else if i != len(config.Website.Cookies) {
			config.Website.Cookies = append(config.Website.Cookies[:i], config.Website.Cookies[i+1:]...)
		}
	}
}

func setQueryParameterMap(queryParameterMap map[string]string, querySlice []string) map[string]string {
	for _, q := range querySlice {
		q = strings.TrimSuffix(q, "\r")
		q = strings.TrimSpace(q)
		if q == "" {
			continue
		} else if !strings.Contains(q, "=") {
			log.Printf("Specified parameter %s doesn't contain a = and will be skipped\n", q)
			continue
		} else {
			query := strings.SplitN(q, "=", 2)
			// ok is true, if a query already is set
			val, ok := queryParameterMap[query[0]]
			if ok {
				log.Printf("Overwriting %s=%s with %s=%s\n", query[0], val, query[0], query[1])
			}
			queryParameterMap[query[0]] = query[1]
		}
	}

	return queryParameterMap
}

func addCacheBuster(strUrl string, cb string, cacheBuster string) (string, string) {
	if cb == "" {
		cb = randInt()
	}
	strUrl += cacheBuster + "=" + cb

	return strUrl, cb
}

/* Create a random long integer */
func randInt() string {
	min := 100000000
	max := 999999999
	result := min + rand.Intn(max-min)
	return strconv.Itoa(result)
}

/* Scan cookies for poisoning */
func ScanCookies(client http.Client, config *Config) {
	for i := 0; i < len(config.Website.Cookies); i++ {
		poison := randInt()
		log.Println("Checking cookie", config.Website.Cookies[i].Name)

		urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

		errorMessage := config.Website.Cookies[i].String() + "=" + config.Website.Cookies[i].Value

		var req *http.Request
		var err error
		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			log.Fatalln(errorMessage, err)
		}

		log.Printf("Overwriting %s=%s with %s=%s\n", config.Website.Cookies[i].Name, config.Website.Cookies[i].Value, config.Website.Cookies[i].Name, poison)
		oldValue := config.Website.Cookies[i].Value
		config.Website.Cookies[i].Value = poison

		setRequest(req, config.DoPost, config)

		resp, err := client.Do(req)
		if err != nil {
			log.Fatalln(errorMessage, err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			log.Printf("Unexpected Status Code %d for %s=%s\n", resp.StatusCode, config.Website.Cookies[i], config.Website.Cookies[i].Value)
		}

		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(errorMessage, err)
		}

		config.Website.Cookies[i].Value = oldValue

		//TODO: Compare (at first) ContentLength instead of whole body?
		if string(body) == config.Website.Body {
			continue
		}

		if config.DoPost {
			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
		} else {
			req, err = http.NewRequest("GET", urlCb, nil)
		}
		if err != nil {
			log.Fatalln(errorMessage, err)
		}

		setRequest(req, config.DoPost, config)
		resp, err = client.Do(req)
		if err != nil {
			log.Fatalln(errorMessage, err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != config.Website.StatusCode {
			log.Printf("Unexpected Status Code %d for %s=%s\n", resp.StatusCode, config.Website.Cookies[i], config.Website.Cookies[i].Value)
		}

		body, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(errorMessage, err)
		}

		if strings.Contains(string(body), poison) {
			log.Println("")
			log.Printf("------- Cookie %s was successfully poisoned!!! cb: %s poison: %s -------\n", config.Website.Cookies[i].Name, cb, poison)
		}
	}
}

/* Scan X-Forward headers for poisoning */
func ScanXForwardHeaders(client http.Client, config *Config) {
	poison := randInt()

	urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)

	var req *http.Request
	var err error
	if config.DoPost {
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		log.Fatalln(err)
	}

	setRequest(req, config.DoPost, config)

	if h := req.Header.Get("X-Forwarded-Host"); h != "" {
		log.Println("Overwriting X-Forwarded-Host" + ":" + h + " with X-Forwarded-Host:" + poison)
		req.Header.Set("X-Forwarded-Host", poison)
	} else {
		req.Header.Add("X-Forwarded-Host", poison)
	}
	if h := req.Header.Get("X-Forwarded-Scheme"); h != "" {
		log.Println("Overwriting X-Forwarded-Scheme" + ":" + h + " with X-Forwarded-Scheme:nothttps")
		req.Header.Set("X-Forwarded-Scheme", "nothttps")
	} else {
		req.Header.Add("X-Forwarded-Scheme", "nothttps")
	}

	resp, err := client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		log.Printf("Unexpected Status Code %d\n", resp.StatusCode)
	}

	//TODO: Check first request, if second is necessary?
	if config.DoPost {
		req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
	} else {
		req, err = http.NewRequest("GET", urlCb, nil)
	}
	if err != nil {
		log.Fatalln(err)
	}

	setRequest(req, config.DoPost, config)
	resp, err = client.Do(req)
	if err != nil {
		log.Fatalln(err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != config.Website.StatusCode {
		log.Printf("Unexpected Status Code %d\n", resp.StatusCode)
	}

	if strings.Contains(resp.Header.Get("Location"), poison) || strings.Contains(req.Host, poison) {
		log.Println("")
		log.Println("------- X-Forwarded-Host and X-Forwarded-Scheme was successfully poisoned!!! cb:", cb, "poison:", poison, "-------")
	}
}

/* Scan headers for poisoning */
func ScanHeaders(client http.Client, headerList []string, config *Config) {
	//c := make(chan result) //<- needed?
	sem := make(chan int, config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(headerList))

	for i, s := range headerList {
		if s == "" {
			if config.Verbosity >= 2 {
				log.Printf("Skipping empty header (%d/%d) %s\n", i+1, len(headerList), s)
			}
			wg.Done()
			continue
		}

		poison := randInt()

		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			s = strings.Trim(s, "\r")

			if config.Verbosity >= 2 {
				log.Printf("Testing now (%d/%d) %s\n", i+1, len(headerList), s)
			}

			urlCb, cb := addCacheBuster(config.Website.Url.String(), "", config.CacheBuster)
			var req *http.Request
			var err error
			if config.DoPost {
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			setRequest(req, config.DoPost, config)

			if h := req.Header.Get(s); h != "" {
				log.Printf("Overwriting %s:%s with %s:%s\n", s, h, s, poison)
				req.Header.Set(s, poison)
			} else {
				req.Header.Add(s, poison)
			}

			resp, err := client.Do(req)
			if err != nil {
				<-sem
				log.Println(s, err)
				req.Header.Del(s)
				return
			}
			req.Header.Del(s)

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for header %s=%s\n", resp.StatusCode, s, poison)
			}

			defer resp.Body.Close()
			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			if string(body) == config.Website.Body {
				<-sem
				return
			}

			if config.DoPost {
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for header %s\n", resp.StatusCode, s)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			if strings.Contains(string(body), poison) {
				log.Println("")
				log.Printf("------- Header %s was successfully poisoned!!! cb: %s poison: %s -------\n", s, cb, poison)
			}

			<-sem
		}(i, s, poison)

	}
	wg.Wait()
}

/* Scan query parameters for poisoning */
func ScanParameters(client http.Client, parameterList []string, config *Config) {
	//c := make(chan result) //<- needed?
	sem := make(chan int, config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(parameterList))

	for i, s := range parameterList {
		if s == "" {
			if config.Verbosity >= 2 {
				log.Printf("Skipping empty query (%d/%d) %s\n", i+1, len(parameterList), s)
			}
			wg.Done()
			continue
		}

		poison := randInt()

		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			s = strings.Trim(s, "\r")

			if config.Verbosity >= 2 {
				log.Printf("Testing now simple fat GET (%d/%d) %s\n", i+1, len(parameterList), s)
			}

			var urlCb, cb string
			if _, ok := config.Website.Queries[s]; ok {
				// if the query to add is already present
				queryParameterMap := make(map[string]string)

				for key, val := range config.Website.Queries {
					queryParameterMap[key] = val
				}

				log.Printf("Overwriting %s=%s with %s=%s\n", s, queryParameterMap[s], s, poison)
				queryParameterMap[s] = poison

				urlCb = config.Website.BaseUrlStr + "?"
				for key, val := range queryParameterMap {
					if !strings.HasSuffix(urlCb, "?") {
						urlCb += "&"
					}
					urlCb += key + "=" + val
				}

				urlCb, cb = addCacheBuster(urlCb+config.QuerySeperator, "", config.CacheBuster)
			} else {
				// if query isn't already present, just add it and the cachebuster
				urlCb = config.Website.Url.String()
				urlCb += s + "=" + poison + config.QuerySeperator
				urlCb, cb = addCacheBuster(urlCb, "", config.CacheBuster)
			}

			var req *http.Request
			var err error
			if config.DoPost {
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			setRequest(req, config.DoPost, config)
			resp, err := client.Do(req)
			if err != nil {
				<-sem
				log.Println(s, err)
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for parameter %s=%s\n", resp.StatusCode, s, poison)
			}

			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			// check if something changed
			if string(body) == config.Website.Body {
				<-sem
				return
			}

			impactfulQueries = append(impactfulQueries, s)

			// get urlCb with the cachebuster but without the poisoned query
			urlCb, cb = addCacheBuster(website.Url.String(), cb, config.CacheBuster)

			if config.DoPost {
				req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(config.Body))
			} else {
				req, err = http.NewRequest("GET", urlCb, nil)
			}
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			if strings.Contains(string(body), poison) {
				log.Println("")
				log.Printf("------- Query Parameter %s was successfully poisoned!!! cb: %s poison: %s -------\n", s, cb, poison)
			}

			<-sem
		}(i, s, poison)

	}
	wg.Wait()
}

/* Check for fat GET */
func ScanFatGET(client http.Client, config *Config) {

	if len(impactfulQueries) == 0 {
		log.Println("No impactful query parameters were found beforehand. Run the query parameter scan (maybe with a different wordlist).")
		return
	}

	//c := make(chan result) //<- needed?
	sem := make(chan int, config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(impactfulQueries))

	for i, s := range impactfulQueries {

		poison := randInt()

		// basic fat get technique
		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			if config.Verbosity >= 2 {
				log.Printf("Testing now simple fat GET (%d/%d) %s\n", i+1, len(impactfulQueries), s)
			}

			urlCb, cb := addCacheBuster(website.Url.String(), "", config.CacheBuster)

			var req *http.Request
			var err error

			req, err = http.NewRequest("GET", urlCb, bytes.NewBufferString(s+"="+poison))
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			setRequest(req, config.DoPost, config)
			resp, err := client.Do(req)
			if err != nil {
				<-sem
				log.Println(s, err)
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
			}

			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			// check if something changed
			if string(body) == config.Website.Body {
				<-sem
				return
			}

			// get urlCb with the cachebuster but without the poisoned query
			urlCb, cb = addCacheBuster(website.Url.String(), cb, config.CacheBuster)

			req, err = http.NewRequest("GET", urlCb, nil)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			if strings.Contains(string(body), poison) {
				log.Println("")
				log.Printf("------- Query Parameter %s was successfully poisoned via simple fat GET!!! cb: %s poison:%s -------\n", s, cb, poison)
			}

			<-sem
		}(i, s, poison)
	}
	wg.Wait()
	wg.Add(len(impactfulQueries))
	log.Println()
	for i, s := range impactfulQueries {

		poison := randInt()

		// X-HTTP-Method-Override fat get technique
		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			if config.Verbosity >= 2 {
				log.Printf("Testing now X-HTTP-Method-Override fat GET (%d/%d) %s\n", i+1, len(impactfulQueries), s)
			}

			urlCb, cb := addCacheBuster(website.Url.String(), "", config.CacheBuster)

			var req *http.Request
			var err error

			req, err = http.NewRequest("GET", urlCb, bytes.NewBufferString(s+"="+poison))
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			//true so ContentType will be set
			setRequest(req, true, config)

			if h := req.Header.Get("X-HTTP-Method-Override"); h != "" {
				log.Printf("Overwriting X-HTTP-Method-Override: %s with X-HTTP-Method-Override:%s\n", h, poison)
				req.Header.Set("X-HTTP-Method-Override", "POST")
			} else {
				req.Header.Add("X-HTTP-Method-Override", "POST")
			}

			resp, err := client.Do(req)
			if err != nil {
				<-sem
				log.Println(s, err)
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
			}

			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			// check if something changed
			if string(body) == config.Website.Body {
				<-sem
				return
			}

			// get urlCb with the cachebuster but without the poisoned query
			urlCb, cb = addCacheBuster(config.Website.Url.String(), cb, config.CacheBuster)

			req, err = http.NewRequest("GET", urlCb, nil)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			if strings.Contains(string(body), poison) {
				log.Println("")
				log.Printf("------- Query Parameter %s was successfully poisoned via X-HTTP-Method-Override fat GET!!! cb:%s poison:%s-------\n", s, cb, poison)
			}

			<-sem
		}(i, s, poison)
	}
	wg.Wait()
	wg.Add(len(impactfulQueries))
	log.Println()
	for i, s := range impactfulQueries {

		poison := randInt()

		// basic fat get technique. Also add go func for POST technique and X-Override-HTTP-Method:POST technique
		go func(i int, s string, poison string) {
			defer wg.Done()
			sem <- 1

			if config.Verbosity >= 2 {
				log.Printf("Testing now POST fat GET (%d/%d) %s\n", i+1, len(impactfulQueries), s)
			}

			urlCb, cb := addCacheBuster(website.Url.String(), "", config.CacheBuster)

			var req *http.Request
			var err error

			req, err = http.NewRequest("POST", urlCb, bytes.NewBufferString(s+"="+poison))
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			// True so ContentType will be set
			setRequest(req, true, config)

			resp, err := client.Do(req)
			if err != nil {
				<-sem
				log.Println(s, err)
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
			}

			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			// check if something changed
			if string(body) == config.Website.Body {
				<-sem
				return
			}

			// get urlCb with the cachebuster but without the poisoned query
			urlCb, cb = addCacheBuster(config.Website.Url.String(), cb, config.CacheBuster)

			req, err = http.NewRequest("GET", urlCb, nil)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			setRequest(req, config.DoPost, config)
			resp, err = client.Do(req)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}
			defer resp.Body.Close()

			if resp.StatusCode != config.Website.StatusCode {
				log.Printf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
			}

			body, err = ioutil.ReadAll(resp.Body)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			if strings.Contains(string(body), poison) {
				log.Println("")
				log.Printf("------- Query Parameter %s was successfully poisoned via simple fat GET!!! cb:%s poison:%s -------\n", s, cb, poison)
			}

			<-sem
		}(i, s, poison)

	}
	wg.Wait()
}

/* Check for fat GET */
func ScanParameterCloaking(client http.Client, config *Config) {

	if len(impactfulQueries) == 0 {
		log.Println("No impactful query parameters were found beforehand. Run the query parameter scan (maybe with a different wordlist).")
		return
	}

	utm_parameter := []string{"utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"}
	unkeyed_parameter := []string{}

	urlCb, _ := addCacheBuster(website.Url.String(), "")

	var req *http.Request
	var err error

	/***********Check if urlCb already contains utm parameter.
				Check if ? or querySeperator is needed
	****************/
	req, err = http.NewRequest("GET", urlCb, nil)
	if err != nil {
		log.Fatalln("first request", err)
	}

	setRequest(req, config.DoPost)
	resp, err := client.Do(req)
	if err != nil {
		log.Println("first request", err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != website.StatusCode {
		log.Printf("Unexpected Status Code %d for first request\n", resp.StatusCode)
	}

	//c := make(chan result) //<- needed?
	sem := make(chan int, config.Threads)
	var wg sync.WaitGroup
	wg.Add(len(utm_parameter))

	for i, s := range utm_parameter {
		go func(i int, s string) {
			defer wg.Done()
			sem <- 1

			if config.Verbosity >= 2 {
				log.Printf("Testing now for unkeyed query parameters (%d/%d) %s\n", i+1, len(impactfulQueries), s)
			}

			var req *http.Request
			var err error

			req, err = http.NewRequest("GET", urlCb, nil)
			if err != nil {
				<-sem
				log.Fatalln(s, err)
			}

			setRequest(req, config.DoPost)
			resp, err := client.Do(req)
			if err != nil {
				<-sem
				log.Println(s, err)
				return
			}
			defer resp.Body.Close()

			//TODO: TEST FOR UNEXPECTED RESPONSE CODE

			/************** if cache hit ************/
			if true {
				unkeyed_parameter = append(unkeyed_parameter, s)
			}

		}(i, s)
	}
	wg.Wait()

	/********************************************************/
	unkeyed_parameter = append(unkeyed_parameter, "utm_content")
	/********************************************************/

	if len(unkeyed_parameter) == 0 {
		log.Println("No unkeyed utm parameters could be found. Parameter Cloaking is not possible using utm parameters")
	} else {
		log.Printf("The following utm parameters were found to be unkeyed and will be now testet for parameter cloaking: %s\n", unkeyed_parameter)
	}

	cloak := ";"
	if config.QuerySeperator == ";" {
		cloak = "&"
	}

	wg.Add(len(impactfulQueries))

	for iu, u := range unkeyed_parameter {
		for is, s := range impactfulQueries {

			poison := randInt()

			go func(iu int, u string, is int, s string, poison string) {
				defer wg.Done()
				sem <- 1

				if config.Verbosity >= 2 {
					log.Printf("Testing now Parameter Cloaking (%d/%d) %s%s%s\n", iu+is+1, len(impactfulQueries)*len(unkeyed_parameter), u, cloak, s)
				}

				urlCb, cb := addCacheBuster(website.Url.String(), "")

				var req *http.Request
				var err error

				/***************	add u=test cloak s=poison
				**************/
				req, err = http.NewRequest("GET", urlCb, nil)
				if err != nil {
					<-sem
					log.Fatalln(s, err)
				}

				setRequest(req, config.DoPost)
				resp, err := client.Do(req)
				if err != nil {
					<-sem
					log.Println(s, err)
					return
				}
				defer resp.Body.Close()

				if resp.StatusCode != website.StatusCode {
					log.Printf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
				}

				body, err := ioutil.ReadAll(resp.Body)
				if err != nil {
					<-sem
					log.Fatalln(s, err)
				}

				// check if something changed
				if string(body) == website.Body {
					<-sem
					return
				}

				// get urlCb with the cachebuster but without the poisoned query
				urlCb, cb = addCacheBuster(website.Url.String(), cb)

				req, err = http.NewRequest("GET", urlCb, nil)
				if err != nil {
					<-sem
					log.Fatalln(s, err)
				}

				setRequest(req, config.DoPost)
				resp, err = client.Do(req)
				if err != nil {
					<-sem
					log.Fatalln(s, err)
				}
				defer resp.Body.Close()

				if resp.StatusCode != website.StatusCode {
					log.Printf("Unexpected Status Code %d for parameter %s\n", resp.StatusCode, s)
				}

				body, err = ioutil.ReadAll(resp.Body)
				if err != nil {
					<-sem
					log.Fatalln(s, err)
				}

				if strings.Contains(string(body), poison) {
					log.Println("")
					log.Printf("------- Query Parameter %s was successfully poisoned via simple fat GET!!! cb:%s poison:%s -------\n", s, cb, poison)
				}

				<-sem
			}(iu, u, is, s, poison)
		}
	}
	wg.Wait()
}
